{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FastAPI-motor-oil","text":"<p>This project is deprecated and replaced by motorhead, adding Pydantic v2 support along with a couple of smaller improvements. Please create an issue if you need help with the migration.</p> <p><code>FastAPI-motor-oil</code> is a collection of async utilities for working with MongoDB and conveniently creating performant APIs with async web frameworks such a FastAPI.</p> <p>Key features:</p> <ul> <li>Database model design with <code>Pydantic</code>.</li> <li>Relationship support and validation using async validators and delete rules with a declarative, decorator-based syntax.</li> <li>Declarative index specification.</li> <li>Typed utilities for convenient model and API creation.</li> <li>Ready to use, customizable async service layer with transaction support that integrates all the above to keep your API and business logic clean, flexible, and easy to understand.</li> </ul> <p>By providing a convenient, declarative middle layer between MongoDB and your API, <code>FastAPI-motor-oil</code> is halfway between an object document mapper (based on <code>Pydantic</code>) and a database driver (by wrapping the official, async <code>motor</code> driver).</p>"},{"location":"#installation","title":"Installation","text":"<p>The library is available on PyPI and can be installed with:</p> <pre><code>$ pip install fastapi-motor-oil\n</code></pre>"},{"location":"#dependencies","title":"Dependencies","text":"<p>The project depends on <code>motor</code> (the official async MongoDB driver, which is built on top of <code>pymongo</code> and <code>bson</code>) and <code>pydantic</code>.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome.</p>"},{"location":"#license","title":"License","text":"<p>The library is open-sourced under the conditions of the MIT license.</p>"},{"location":"api-bound-method-wrapper/","title":"Bound method wrapper","text":""},{"location":"api-bound-method-wrapper/#fastapi_motor_oil.bound_method_wrapper.BoundMethodWrapper","title":"<code>BoundMethodWrapper</code>","text":"<p>             Bases: <code>Generic[TOwner, TParams, TConfig]</code></p> <p>Async method wrapper that also acts as a bound instance method when it replaces an instance method of a class.</p> <p>Note: the wrapped method will be unbound.</p> Caveats <p>This class acts as if it was a bound method of the instance using the descriptor protocol, but of course it is not a bound method, which becomes important when trying to apply decorators on the wrapper instance. In those cases the wrapper acts as a static method whose first argument is the instance, so you need to apply decorators that match this signature.</p> Configuration <p>exception: An optional exception factory (or type) that accepts a single string            argument and returns an exception. If not <code>None</code>, then exceptions            raised by the wrapped method will be caught and replaced by the exception            this method produces.</p> Source code in <code>fastapi_motor_oil/bound_method_wrapper.py</code> <pre><code>class BoundMethodWrapper(Generic[TOwner, TParams, TConfig]):\n\"\"\"\n    Async method wrapper that also acts as a bound instance method when it replaces\n    an instance method of a class.\n    Note: the wrapped method will be unbound.\n    Caveats:\n        This class acts as if it was a bound method of the instance using the\n        descriptor protocol, but of course it is not a bound method, which becomes\n        important when trying to apply decorators on the wrapper instance. In those\n        cases the wrapper acts as a static method whose first argument is the instance,\n        so you need to apply decorators that match this signature.\n    Configuration:\n        exception: An optional exception factory (or type) that accepts a single string\n                   argument and returns an exception. If not `None`, then exceptions\n                   raised by the wrapped method will be caught and replaced by the exception\n                   this method produces.\n    \"\"\"\n__slots__ = (\n\"_config\",\n\"_func\",\n)\nexception: Callable[[str], Exception] | None = None\ndef __init__(\nself,\nfunc: Callable[Concatenate[TOwner, TParams], Coroutine[None, None, None]],\nconfig: TConfig,\n) -&gt; None:\n\"\"\"\n        Initialization.\n        Arguments:\n            func: The wrapped method.\n            config: Wrapper configuration.\n        \"\"\"\nself._config = config\nself._func = func\n@property\ndef config(self) -&gt; TConfig:\n\"\"\"\n        Wrapper configuration.\n        \"\"\"\nreturn self._config\n@property\ndef name(self) -&gt; str:\n\"\"\"\n        The (qualified) name of the wrapped method.\n        \"\"\"\nreturn self._func.__qualname__\ndef __get__(\nself, owner: TOwner, obj_type: Type[TOwner] | None = None\n) -&gt; Callable[TParams, Coroutine[None, None, None]]:\n\"\"\"\n        Descriptor implementation that makes the wrapper work as a bound method of its owner.\n        \"\"\"\nasync def do(*args: TParams.args, **kwargs: TParams.kwargs) -&gt; None:\nreturn await self(owner, *args, **kwargs)\nreturn do\nasync def __call__(self, owner: TOwner, *args: TParams.args, **kwargs: TParams.kwargs) -&gt; None:\n\"\"\"\n        Executes the wrapped *unbound* method with the given `owner`.\n        Exceptions raised by the wrapped method will be transformed by the `exception` attribute.\n        Arguments:\n            owner: The owner instance of the wrapper (the `self` argument of the wrapped instance method).\n            *args: The wrapped method's positional arguments.\n            *kwargs: The wrapped method's keyword arguments.\n        \"\"\"\ntry:\nawait self._func(owner, *args, **kwargs)\nexcept Exception as e:\nraise e if self.exception is None else self.exception(f\"Method failed: {self.name}\") from e\n</code></pre>"},{"location":"api-bound-method-wrapper/#fastapi_motor_oil.bound_method_wrapper.BoundMethodWrapper.config","title":"<code>config: TConfig</code>  <code>property</code>","text":"<p>Wrapper configuration.</p>"},{"location":"api-bound-method-wrapper/#fastapi_motor_oil.bound_method_wrapper.BoundMethodWrapper.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>The (qualified) name of the wrapped method.</p>"},{"location":"api-bound-method-wrapper/#fastapi_motor_oil.bound_method_wrapper.BoundMethodWrapper.__call__","title":"<code>__call__(owner, *args, **kwargs)</code>  <code>async</code>","text":"<p>Executes the wrapped unbound method with the given <code>owner</code>.</p> <p>Exceptions raised by the wrapped method will be transformed by the <code>exception</code> attribute.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>TOwner</code> <p>The owner instance of the wrapper (the <code>self</code> argument of the wrapped instance method).</p> required <code>*args</code> <code>TParams.args</code> <p>The wrapped method's positional arguments.</p> <code>()</code> <code>*kwargs</code> <code>TParams.kwargs</code> <p>The wrapped method's keyword arguments.</p> <code>{}</code> Source code in <code>fastapi_motor_oil/bound_method_wrapper.py</code> <pre><code>async def __call__(self, owner: TOwner, *args: TParams.args, **kwargs: TParams.kwargs) -&gt; None:\n\"\"\"\n    Executes the wrapped *unbound* method with the given `owner`.\n    Exceptions raised by the wrapped method will be transformed by the `exception` attribute.\n    Arguments:\n        owner: The owner instance of the wrapper (the `self` argument of the wrapped instance method).\n        *args: The wrapped method's positional arguments.\n        *kwargs: The wrapped method's keyword arguments.\n    \"\"\"\ntry:\nawait self._func(owner, *args, **kwargs)\nexcept Exception as e:\nraise e if self.exception is None else self.exception(f\"Method failed: {self.name}\") from e\n</code></pre>"},{"location":"api-bound-method-wrapper/#fastapi_motor_oil.bound_method_wrapper.BoundMethodWrapper.__get__","title":"<code>__get__(owner, obj_type=None)</code>","text":"<p>Descriptor implementation that makes the wrapper work as a bound method of its owner.</p> Source code in <code>fastapi_motor_oil/bound_method_wrapper.py</code> <pre><code>def __get__(\nself, owner: TOwner, obj_type: Type[TOwner] | None = None\n) -&gt; Callable[TParams, Coroutine[None, None, None]]:\n\"\"\"\n    Descriptor implementation that makes the wrapper work as a bound method of its owner.\n    \"\"\"\nasync def do(*args: TParams.args, **kwargs: TParams.kwargs) -&gt; None:\nreturn await self(owner, *args, **kwargs)\nreturn do\n</code></pre>"},{"location":"api-bound-method-wrapper/#fastapi_motor_oil.bound_method_wrapper.BoundMethodWrapper.__init__","title":"<code>__init__(func, config)</code>","text":"<p>Initialization.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[TOwner, TParams], Coroutine[None, None, None]]</code> <p>The wrapped method.</p> required <code>config</code> <code>TConfig</code> <p>Wrapper configuration.</p> required Source code in <code>fastapi_motor_oil/bound_method_wrapper.py</code> <pre><code>def __init__(\nself,\nfunc: Callable[Concatenate[TOwner, TParams], Coroutine[None, None, None]],\nconfig: TConfig,\n) -&gt; None:\n\"\"\"\n    Initialization.\n    Arguments:\n        func: The wrapped method.\n        config: Wrapper configuration.\n    \"\"\"\nself._config = config\nself._func = func\n</code></pre>"},{"location":"api-delete-rule/","title":"Delete rules","text":""},{"location":"api-delete-rule/#fastapi_motor_oil.delete_rule.DeleteConfig","title":"<code>DeleteConfig = Literal['deny', 'pre', 'post']</code>  <code>module-attribute</code>","text":"<p>Delete rule configuration that specifies when a given delete rule must be executed.</p>"},{"location":"api-delete-rule/#fastapi_motor_oil.delete_rule.DeleteRule","title":"<code>DeleteRule</code>","text":"<p>             Bases: <code>BoundMethodWrapper[TOwner, [AgnosticClientSession, Sequence[ObjectId]], DeleteConfig]</code></p> <p>Delete rule wrapper.</p> <p>Delete rules receive an <code>AgnosticClientSession</code> instance and a list of <code>ObjectId</code>s, and implement any deny, pre- or post-delete behavior.</p> <p>Delete rule execution sequence:</p> <ul> <li>\"deny\" rules are executed first - delete rules whose role is to prevent   a delete operation should have this config.</li> <li>\"pre\" rules are executed next.</li> <li>Then the requested delete operation takes place.</li> <li>Finally the \"post\" delete rules are executed.</li> </ul> <p>Delete rules are always called in a transaction. Well-behaved delete rules must:</p> <ul> <li>always use the received session instance to interact with the database,   i.e. forward the received session to every database driver call;</li> <li>not commit the session;</li> <li>not start a new transaction (see <code>session.in_transaction</code>);</li> <li>raise an exception if the operation can or must not complete.</li> </ul> <p>Example:</p> <pre><code>class SVC(MongoService):\n@delete_rule(\"pre\")\nasync def delete_cascade(self, session: AgnosticClientSession, ids: Sequence[ObjectId]) -&gt; None:\nfrom x.y.z import OtherService\nother_service = OtherService(self._database)\nawait other_service.delete_many({\"foo_ref\": {\"$in\": ids}}, options={\"session\": session})\n</code></pre> Source code in <code>fastapi_motor_oil/delete_rule.py</code> <pre><code>class DeleteRule(BoundMethodWrapper[TOwner, [AgnosticClientSession, Sequence[ObjectId]], DeleteConfig]):\n\"\"\"\n    Delete rule wrapper.\n    Delete rules receive an `AgnosticClientSession` instance and a list of `ObjectId`s,\n    and implement any deny, pre- or post-delete behavior.\n    Delete rule execution sequence:\n    - \"deny\" rules are executed first - delete rules whose role is to prevent\n      a delete operation should have this config.\n    - \"pre\" rules are executed next.\n    - Then the requested delete operation takes place.\n    - Finally the \"post\" delete rules are executed.\n    Delete rules are always called in a transaction. Well-behaved delete rules must:\n    - always use the received session instance to interact with the database,\n      i.e. forward the received session to every database driver call;\n    - *not* commit the session;\n    - *not* start a new transaction (see `session.in_transaction`);\n    - raise an exception if the operation can or must not complete.\n    Example:\n    ```python\n    class SVC(MongoService):\n        @delete_rule(\"pre\")\n        async def delete_cascade(self, session: AgnosticClientSession, ids: Sequence[ObjectId]) -&gt; None:\n            from x.y.z import OtherService\n            other_service = OtherService(self._database)\n            await other_service.delete_many({\"foo_ref\": {\"$in\": ids}}, options={\"session\": session})\n    ```\n    \"\"\"\n__slots__ = ()\nexception = DeleteError\n</code></pre>"},{"location":"api-delete-rule/#fastapi_motor_oil.delete_rule.delete_rule","title":"<code>delete_rule(config='pre')</code>","text":"<p>Decorator that converts a <code>MongoService</code> method into a <code>DeleteRule</code> that is then automatically applied by the service during delete operations.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>DeleteConfig</code> <p>Delete rule configuration.</p> <code>'pre'</code> Source code in <code>fastapi_motor_oil/delete_rule.py</code> <pre><code>def delete_rule(\nconfig: DeleteConfig = \"pre\",\n) -&gt; Callable[\n[Callable[[TOwner, AgnosticClientSession, Sequence[ObjectId]], Coroutine[None, None, None]]],\n\"DeleteRule[TOwner]\",\n]:\n\"\"\"\n    Decorator that converts a `MongoService` method into a `DeleteRule` that is then\n    automatically applied by the service during delete operations.\n    Arguments:\n        config: Delete rule configuration.\n    \"\"\"\ndef decorator(\nfunc: Callable[[TOwner, AgnosticClientSession, Sequence[ObjectId]], Coroutine[None, None, None]], /\n) -&gt; \"DeleteRule[TOwner]\":\nreturn DeleteRule(func=func, config=config)\nreturn decorator\n</code></pre>"},{"location":"api-model/","title":"Utility models and protocols","text":""},{"location":"api-model/#fastapi_motor_oil.model.ClientProvider","title":"<code>ClientProvider</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Client provider protocol for FastAPI database dependencies.</p> Source code in <code>fastapi_motor_oil/model.py</code> <pre><code>class ClientProvider(Protocol):\n\"\"\"\n    Client provider protocol for FastAPI database dependencies.\n    \"\"\"\ndef __call__(self) -&gt; AgnosticClient:\n...\n</code></pre>"},{"location":"api-model/#fastapi_motor_oil.model.DatabaseProvider","title":"<code>DatabaseProvider</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Database provider protocol for FastAPI database dependencies.</p> Source code in <code>fastapi_motor_oil/model.py</code> <pre><code>class DatabaseProvider(Protocol):\n\"\"\"\n    Database provider protocol for FastAPI database dependencies.\n    \"\"\"\ndef __call__(self) -&gt; AgnosticDatabase:\n...\n</code></pre>"},{"location":"api-model/#fastapi_motor_oil.model.DeleteResultModel","title":"<code>DeleteResultModel</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Delete result model.</p> Source code in <code>fastapi_motor_oil/model.py</code> <pre><code>class DeleteResultModel(BaseModel):\n\"\"\"\n    Delete result model.\n    \"\"\"\ndelete_count: int\n</code></pre>"},{"location":"api-model/#fastapi_motor_oil.model.DocumentModel","title":"<code>DocumentModel</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Pydantic base model for MongoDB documents.</p> <p>It exposes the <code>_id</code> attribute as <code>id</code>.</p> Source code in <code>fastapi_motor_oil/model.py</code> <pre><code>class DocumentModel(BaseModel):\n\"\"\"\n    Pydantic base model for MongoDB documents.\n    It exposes the `_id` attribute as `id`.\n    \"\"\"\nid: StrObjectId = Field(alias=\"_id\")\nclass Config:\narbitrary_types_allowed = True\njson_encoders = {ObjectId: str}\n</code></pre>"},{"location":"api-model/#fastapi_motor_oil.model.StrObjectId","title":"<code>StrObjectId</code>","text":"<p>             Bases: <code>ObjectId</code></p> <p>Custom BSON <code>ObjectId</code> for use with Pydantic.</p> Source code in <code>fastapi_motor_oil/model.py</code> <pre><code>class StrObjectId(ObjectId):\n\"\"\"\n    Custom BSON `ObjectId` for use with Pydantic.\n    \"\"\"\n@classmethod\ndef __get_validators__(cls) -&gt; Generator[Callable[[Any], StrObjectId], None, None]:\nyield cls.validate\n@classmethod\ndef validate(cls, value: Any) -&gt; StrObjectId:\n\"\"\"\n        Checks whether the given value is a valid `ObjectId`\"\"\"\nif not ObjectId.is_valid(value):\nraise ValueError(\"Invalid StrObjectId\")\nreturn cls(value)\n@classmethod\ndef __modify_schema__(cls, field_schema: dict[str, Any]) -&gt; None:\nfield_schema.update(type=\"string\")\n</code></pre>"},{"location":"api-model/#fastapi_motor_oil.model.StrObjectId.validate","title":"<code>validate(value)</code>  <code>classmethod</code>","text":"<p>Checks whether the given value is a valid <code>ObjectId</code></p> Source code in <code>fastapi_motor_oil/model.py</code> <pre><code>@classmethod\ndef validate(cls, value: Any) -&gt; StrObjectId:\n\"\"\"\n    Checks whether the given value is a valid `ObjectId`\"\"\"\nif not ObjectId.is_valid(value):\nraise ValueError(\"Invalid StrObjectId\")\nreturn cls(value)\n</code></pre>"},{"location":"api-model/#fastapi_motor_oil.model.UTCDatetime","title":"<code>UTCDatetime</code>","text":"<p>             Bases: <code>datetime</code></p> <p>Pydantic datetime field that enforces UTC timezone.</p> Source code in <code>fastapi_motor_oil/model.py</code> <pre><code>class UTCDatetime(datetime):\n\"\"\"\n    Pydantic datetime field that enforces UTC timezone.\n    \"\"\"\n@classmethod\ndef __get_validators__(cls) -&gt; Generator[Any, None, None]:\nyield parse_datetime  # default pydantic behavior\nyield cls.ensure_utc\n@classmethod\ndef ensure_utc(cls, value: datetime) -&gt; datetime:\n\"\"\"\n        Makes sure the given datetime is in UTC.\n        If `value` has no timezone info, the method sets UTC.\n        Raises:\n            ValueError: If `value` has timezone info but it's not UTC.\n        \"\"\"\ntzinfo = value.tzinfo\nif tzinfo is None:  # No timezone info, assume UTC.\nreturn value.replace(tzinfo=timezone.utc)\nif tzinfo == timezone.utc:  # Timezone is UTC, no-op.\nreturn value\n# Non-UTC timezone info, raise exception.\nraise ValueError(\"Non-UTC timezone.\")\n</code></pre>"},{"location":"api-model/#fastapi_motor_oil.model.UTCDatetime.ensure_utc","title":"<code>ensure_utc(value)</code>  <code>classmethod</code>","text":"<p>Makes sure the given datetime is in UTC.</p> <p>If <code>value</code> has no timezone info, the method sets UTC.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>value</code> has timezone info but it's not UTC.</p> Source code in <code>fastapi_motor_oil/model.py</code> <pre><code>@classmethod\ndef ensure_utc(cls, value: datetime) -&gt; datetime:\n\"\"\"\n    Makes sure the given datetime is in UTC.\n    If `value` has no timezone info, the method sets UTC.\n    Raises:\n        ValueError: If `value` has timezone info but it's not UTC.\n    \"\"\"\ntzinfo = value.tzinfo\nif tzinfo is None:  # No timezone info, assume UTC.\nreturn value.replace(tzinfo=timezone.utc)\nif tzinfo == timezone.utc:  # Timezone is UTC, no-op.\nreturn value\n# Non-UTC timezone info, raise exception.\nraise ValueError(\"Non-UTC timezone.\")\n</code></pre>"},{"location":"api-service/","title":"Services","text":""},{"location":"api-service/#fastapi_motor_oil.service.MongoService","title":"<code>MongoService</code>","text":"<p>             Bases: <code>Generic[TInsert, TUpdate]</code></p> <p>Base service with typed utility methods for MongoDB (<code>motor</code> asyncio).</p> <p>The service provides a limited subset of <code>motor</code>'s capabilities.</p> <p>For undocumented keyword arguments, please see the <code>motor</code> or <code>pymongo</code> documentation.</p> <p>For delete rule support, see <code>DeleteRule</code>, <code>delete_many()</code>, and <code>delete_one()</code>.</p> <p>For insert and update data validation, see <code>Validator</code>, <code>_validate_insert()</code>, and <code>_validate_update()</code></p> Class attributes <p>collection_name: The name of the collection the service operates on. Must be set by subclasses. collection_options: Optional <code>CollectionOptions</code> dict.</p> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>class MongoService(Generic[TInsert, TUpdate]):\n\"\"\"\n    Base service with typed utility methods for MongoDB (`motor` asyncio).\n    The service provides a limited subset of `motor`'s capabilities.\n    For undocumented keyword arguments, please see the `motor` or `pymongo` documentation.\n    For delete rule support, see `DeleteRule`, `delete_many()`, and `delete_one()`.\n    For insert and update data validation, see `Validator`, `_validate_insert()`, and `_validate_update()`\n    Class attributes:\n        collection_name: The name of the collection the service operates on. Must be set by subclasses.\n        collection_options: Optional `CollectionOptions` dict.\n    \"\"\"\n__slots__ = (\n\"_collection\",\n\"_database\",\n\"_supports_transactions\",\n)\ncollection_name: str\n\"\"\"\n    The name of the collection the service operates on. Must be set by subclasses.\n    \"\"\"\ncollection_options: CollectionOptions | None = None\n\"\"\"\n    Optional `CollectionOptions` dict.\n    \"\"\"\nindexes: dict[str, IndexData] | None = None\n\"\"\"\n    The full description of the indexes (if any) of the collection.\n    \"\"\"\ndef __init__(self, database: AgnosticDatabase) -&gt; None:\n\"\"\"\n        Initialization.\n        Arguments:\n            database: The database driver.\n        \"\"\"\nif self.collection_name is None:\nraise ValueError(\"MongoService.collection_name is not initialized.\")\nself._database = database\nself._collection: AgnosticCollection | None = None\nself._supports_transactions: bool | None = None\n@property\ndef client(self) -&gt; AgnosticClient:\n\"\"\"\n        The database client.\n        \"\"\"\nreturn self._database.client\n@property\ndef collection(self) -&gt; AgnosticCollection:\n\"\"\"\n        The collection instance of the service.\n        \"\"\"\nif self._collection is None:\nself._collection = self._create_collection()\nreturn self._collection\nasync def supports_transactions(self) -&gt; bool:\n\"\"\"\n        Queries the database if it supports transactions or not.\n        Note: transactions are only supported in replica set configuration.\n        \"\"\"\nif self._supports_transactions is None:\nself._supports_transactions = \"system.replset\" in (await self.client[\"local\"].list_collection_names())\nreturn self._supports_transactions\ndef aggregate(\nself,\npipeline: Sequence[dict[str, Any]],\nsession: AgnosticClientSession | None = None,\n**kwargs: Any,\n) -&gt; AgnosticLatentCommandCursor:\n\"\"\"\n        Performs an aggregation.\n        For undocumented keyword arguments, see the documentation of `pymongo.collection.Collection.aggregate()`.\n        Arguments:\n            pipeline: The aggregation pipeline.\n            session: An optional session to use.\n        \"\"\"\nreturn self.collection.aggregate(pipeline, session=session, **kwargs)\nasync def count_documents(self, query: MongoQuery, *, options: FindOptions | None = None) -&gt; int:\n\"\"\"\n        Returns the number of documents that match the given query.\n        Arguments:\n            query: The query object.\n            options: Query options, see the arguments of `collection.count_documents()` for details.\n        Returns:\n            The number of matching documents.\n        \"\"\"\nreturn await self.collection.count_documents(query, **(options or {}))  # type: ignore[no-any-return]\nasync def create_index(\nself,\nkeys: str | Sequence[tuple[str, int | str | Mapping[str, Any]]],\n*,\nname: str,\nunique: bool = False,\nsession: AgnosticClientSession | None = None,\nbackground: bool = False,\ncollation: Collation | None = None,\nsparse: bool = False,\n**kwargs: Any,\n) -&gt; str:\n\"\"\"\n        Creates the specified index on collection of the service.\n        Arguments:\n            keys: Index description.\n            name: Index name.\n            unique: Whether to create a uniqueness constraint on the index.\n            session: An optional session to use.\n            background: Whether the index should be created in the background.\n            collation: A `Collation` instance.\n            sparse: Whether to omit documents from the index that doesn't have the indexed field.\n        \"\"\"\nreturn await self.collection.create_index(  # type: ignore[no-any-return]\nkeys,\nname=name,\nunique=unique,\nsession=session,\nbackground=background,\ncollation=collation,\nsparse=sparse,\n**kwargs,\n)\nasync def create_indexes(self, session: AgnosticClientSession | None = None) -&gt; None:\n\"\"\"\n        Creates all declared indexes (see cls.indexes) on the collection of the service.\n        Arguments:\n            session: An optional session to use.\n        \"\"\"\nif self.indexes is None:\nreturn\nfor name, idx in self.indexes.items():\nawait self.create_index(\nidx.keys,\nname=name,\nunique=idx.unique,\nbackground=idx.background,\ncollation=idx.collation,\nsparse=idx.sparse,\nsession=session,\n**idx.extra,\n)\nasync def drop_index(\nself,\nindex_or_name: str | Sequence[tuple[str, int | str | Mapping[str, Any]]],\nsession: AgnosticClientSession | None = None,\n**kwargs: Any,\n) -&gt; None:\n\"\"\"\n        Drops the given index from the collection of the service.\n        Arguments:\n            index_or_name: The index to drop.\n            session: An optional session to use.\n        \"\"\"\nreturn await self.collection.drop_index(  # type: ignore[no-any-return]\nindex_or_name,\nsession=session,\n**kwargs,\n)\nasync def drop_indexes(self, session: AgnosticClientSession | None = None, **kwargs: Any) -&gt; None:\n\"\"\"\n        Drops all indexes from the collection of the service.\n        Arguments:\n            session: An optional session to use.\n        \"\"\"\nreturn await self.collection.drop_indexes(session, **kwargs)  # type: ignore[no-any-return]\ndef list_indexes(\nself,\nsession: AgnosticClientSession | None = None,\n**kwargs: Any,\n) -&gt; AgnosticLatentCommandCursor:\n\"\"\"\n        Returns a cursor over the indexes of the collection of the service.\n        Arguments:\n            session: An optional session to use.\n        \"\"\"\nreturn self.collection.list_indexes(session, **kwargs)\nasync def delete_by_id(\nself,\nid: ObjectId,\n*,\noptions: DeleteOptions | None = None,\n) -&gt; DeleteResult:\n\"\"\"\n        Deletes the document with the given ID.\n        This method is just a convenience wrapper around `delete_one()`, see that\n        method for more details.\n        Arguments:\n            id: The ID of the document to delete.\n            options: Delete options, see the arguments of `collection.delete_one()`.\n        Returns:\n            The result of the operation.\n        \"\"\"\nreturn await self.delete_one({\"_id\": id}, options=options)\nasync def delete_many(\nself,\nquery: MongoQuery | None,\n*,\noptions: DeleteOptions | None = None,\n) -&gt; DeleteResult:\n\"\"\"\n        The default `delete_many()` implementation of the service.\n        The method enforces delete rules and executes the operation as follows:\n        1. Enforce `\"deny\"` delete rules.\n        2. Enforce `\"pre\"` delete rules.\n        3. Execute the delete operation.\n        4. Enforce `\"post\"` delete rules.\n        See `DeleteRule` for more information.\n        Arguments:\n            query: Query object that matches the documents that should be deleted.\n            options: Delete options, see the arguments of `collection.delete_many()`.\n        Returns:\n            The result of the operation.\n        \"\"\"\nsession_manager = self._get_session_context_manager(options.get(\"session\", None) if options else None)\nasync with await session_manager() as session:\nopts: DeleteOptions = options or {}\nopts[\"session\"] = session\nctxman = (\nnullcontext\nif session.in_transaction or not await self.supports_transactions()\nelse session.start_transaction\n)\nids: list[ObjectId] | None = (\nawait self.find_ids(query, session=session) if self._has_delete_rules() else None\n)\nhas_ids = ids is not None and len(ids) &gt; 0\nasync with ctxman():\nif has_ids:\nawait self._validate_deny_delete(\nsession,\nids,  # type: ignore[arg-type] # can not be None if has_ids is True\n)\nawait self._validate_pre_delete(\nsession,\nids,  # type: ignore[arg-type] # can not be None if has_ids is True\n)\nresult = await self.collection.delete_many(query, **opts)\nif has_ids:\nawait self._validate_post_delete(\nsession,\nids,  # type: ignore[arg-type] # can not be None if has_ids is True\n)\nreturn result  # type: ignore[no-any-return]\nasync def delete_one(\nself,\nquery: MongoQuery | None,\n*,\noptions: DeleteOptions | None = None,\n) -&gt; DeleteResult:\n\"\"\"\n        The default `delete_one()` implementation of the service.\n        The method enforces delete rules and executes the operation as follows:\n        1. Enforce `\"deny\"` delete rules.\n        2. Enforce `\"pre\"` delete rules.\n        3. Execute the delete operation.\n        4. Enforce `\"post\"` delete rules.\n        See `DeleteRule` for more information.\n        Arguments:\n            query: Query object that matches the document that should be deleted.\n            options: Delete options, see the arguments of `collection.delete_one()`.\n        Returns:\n            The result of the operation.\n        \"\"\"\nsession_manager = self._get_session_context_manager(options.get(\"session\", None) if options else None)\nasync with await session_manager() as session:\nopts: DeleteOptions = options or {}\nopts[\"session\"] = session\nctxman = (\nnullcontext\nif session.in_transaction or not await self.supports_transactions()\nelse session.start_transaction\n)\nids: list[ObjectId] | None = (\nawait self.find_ids(query, session=session) if self._has_delete_rules() else None\n)\nasync with ctxman():\nif ids is not None:\nif len(ids) &gt; 1:\n# Only when the service has delete rules...\nraise ValueError(\"Ambigous delete_one() - multiple documents match the query.\")\nawait self._validate_deny_delete(session, ids)\nawait self._validate_pre_delete(session, ids)\nresult = await self.collection.delete_one(query, **opts)\nif ids is not None:\nawait self._validate_post_delete(session, ids)\nreturn result  # type: ignore[no-any-return]\nasync def exists(self, id: ObjectId, *, options: FindOptions | None = None) -&gt; bool:\n\"\"\"\n        Returns whether the document with the given ID exists.\n        Arguments:\n            id: The ID of the document to check.\n            options: Query options, see the arguments of `collection.count_documents()` for details.\n        Returns:\n            Whether the document with the given ID exists.\n        \"\"\"\nreturn await self.count_documents({\"_id\": id}, options=options) == 1\ndef find(\nself,\nquery: MongoQuery | None = None,\nprojection: MongoProjection | None = None,\n*,\noptions: FindOptions | None = None,\n) -&gt; AgnosticCursor:\n\"\"\"\n        The default `find()` implementation of the service.\n        Arguments:\n            query: The query object.\n            projection: Optional projection.\n            options: Query options, see the arguments of `collection.find()` for details.\n        Returns:\n            An async database cursor.\n        \"\"\"\nreturn self.collection.find(query, projection, **(options or {}))\nasync def find_ids(\nself,\nquery: MongoQuery | None,\n*,\nsession: AgnosticClientSession | None = None,\n) -&gt; list[ObjectId]:\n\"\"\"\n        Returns the IDs of all documents that match the given query.\n        Arguments:\n            query: The query object.\n            session: An optional database session to use.\n        Returns:\n            The IDs of all matching documents.\n        \"\"\"\nreturn [doc[\"_id\"] for doc in await self.collection.find(query, {\"_id\": True}, session=session).to_list(None)]\nasync def find_one(\nself,\nquery: MongoQuery | None = None,\nprojection: MongoProjection | None = None,\n*,\noptions: FindOptions | None = None,\n) -&gt; dict[str, Any] | None:\n\"\"\"\n        The default `find_one()` implementation of the service.\n        Arguments:\n            query: The query object.\n            projection: Optional projection.\n            options: Query options, see the arguments of `collection.find()` for details.\n        Returns:\n            A single matching document or `None` if there are no matches.\n        \"\"\"\nreturn await self.collection.find_one(query, projection, **(options or {}))  # type: ignore[no-any-return]\nasync def get_by_id(\nself,\nid: ObjectId,\nprojection: MongoProjection | None = None,\n*,\noptions: FindOptions | None = None,\n) -&gt; dict[str, Any] | None:\n\"\"\"\n        Returns the document with the given ID if it exists.\n        Arguments:\n            id: The ID of the queried document. Must be an `ObjectID`, not a `str`.\n            projection: Optional projection.\n            options: Query options, see the arguments of `collection.find()` for details.\n        Returns:\n            The queried document if such a document exists.\n        \"\"\"\nreturn await self.find_one({\"_id\": id}, projection, options=options)\nasync def insert_one(self, data: TInsert, *, options: InsertOneOptions | None = None) -&gt; InsertOneResult:\n\"\"\"\n        Inserts the given data into the collection.\n        Arguments:\n            data: The data to be inserted.\n            options: Insert options, see the arguments of `collection.insert_one()` for details.\n        Returns:\n            The result of the operation.\n        Raises:\n            Exception: if the data is invalid.\n        \"\"\"\nreturn await self.collection.insert_one(  # type: ignore[no-any-return]\nawait self._prepare_for_insert(None, data),\n**(options or {}),\n)\nasync def update_by_id(\nself,\nid: ObjectId,\nchanges: TUpdate,\n*,\noptions: UpdateOneOptions | None = None,\n) -&gt; UpdateResult:\n\"\"\"\n        Updates the document with the given ID.\n        Arguments:\n            id: The ID of the document to update.\n            changes: The changes to make.\n            options: Update options, see the arguments of `collection.update_one()` for details.\n        Returns:\n            The result of the operation.\n        Raises:\n            Exception: if the data is invalid.\n        \"\"\"\nreturn await self.update_one({\"_id\": id}, changes, options=options)\nasync def update_many(\nself,\nquery: MongoQuery | None,\nchanges: TUpdate,\n*,\noptions: UpdateManyOptions | None = None,\n) -&gt; UpdateResult:\n\"\"\"\n        The default `delete_many()` implementation of the service.\n        Arguments:\n            query: Query that matches the documents that should be updated.\n            changes: The changes to make.\n            options: Update options, see the arguments of `collection.update_many()` for details.\n        Returns:\n            The result of the operation.\n        Raises:\n            Exception: if the data is invalid.\n        \"\"\"\nreturn await self.collection.update_many(  # type: ignore[no-any-return]\nquery,\nawait self._prepare_for_update(query, changes),\n**(options or {}),\n)\nasync def update_one(\nself,\nquery: MongoQuery | None,\nchanges: TUpdate,\n*,\noptions: UpdateOneOptions | None = None,\n) -&gt; UpdateResult:\n\"\"\"\n        The default `delete_one()` implementation of the service.\n        Arguments:\n            query: Query that matches the document that should be updated.\n            changes: The changes to make.\n            options: Update options, see the arguments of `collection.update_one()` for details.\n        Returns:\n            The result of the operation.\n        Raises:\n            Exception: if the data is invalid.\n        \"\"\"\nreturn await self.collection.update_one(  # type: ignore[no-any-return]\nquery,\nawait self._prepare_for_update(query, changes),\n**(options or {}),\n)\nasync def _convert_for_insert(self, data: TInsert) -&gt; dict[str, Any]:\n\"\"\"\n        Converts the given piece of the into its database representation.\n        The default implementation is simply `data.dict()`.\n        Arguments:\n            data: The data to be inserted.\n        Returns:\n            The MongoDB-compatible, insertable data.\n        Raises:\n            Exception: if the data is invalid.\n        \"\"\"\nreturn data.dict()\nasync def _convert_for_update(self, data: TUpdate) -&gt; UpdateObject | Sequence[UpdateObject]:\n\"\"\"\n        Converts the given piece of data into an update object.\n        The default implementation is `{\"$set\": data.dict(exclude_unset=True)}`.\n        Arguments:\n            data: The update data.\n        Returns:\n            The MongoDB-compatible update object.\n        Raises:\n            Exception: if the data is invalid.\n        \"\"\"\nreturn {\"$set\": data.dict(exclude_unset=True)}\ndef _create_collection(self) -&gt; AgnosticCollection:\n\"\"\"\n        Creates a new `AgnosticCollection` instance for the service.\n        \"\"\"\nreturn self._database.get_collection(self.collection_name, **(self.collection_options or {}))\ndef _delete_rules(self) -&gt; Generator[DeleteRule[\"MongoService[TInsert, TUpdate]\"], None, None]:\n\"\"\"\n        Generator that yields the delete rules that are registered on this service\n        in the order they are present in `__class__.__dict__`.\n        \"\"\"\nfor rule in self.__class__.__dict__.values():\nif isinstance(rule, DeleteRule):\nyield rule\ndef _has_delete_rules(self) -&gt; bool:\n\"\"\"\n        Returns whether the service has any delete rules.\n        \"\"\"\nfor rule in self.__class__.__dict__.values():\nif isinstance(rule, DeleteRule):\nreturn True\nreturn False\ndef _get_session_context_manager(\nself,\nsession: AgnosticClientSession | None,\n) -&gt; Callable[[], Coroutine[None, None, AbstractAsyncContextManager[AgnosticClientSession]]]:\n\"\"\"\n        Returns a session context manager\n        \"\"\"\nif session is None:\n# Return a context manager that actually starts a session.\nreturn self.client.start_session  # type: ignore[no-any-return]\nasync def start_session() -&gt; AbstractAsyncContextManager[AgnosticClientSession]:\n@asynccontextmanager\nasync def ctx_manager() -&gt; AsyncGenerator[AgnosticClientSession, None]:\nyield session\nreturn ctx_manager()\nreturn start_session\nasync def _prepare_for_insert(self, query: MongoQuery | None, data: TInsert) -&gt; dict[str, Any]:\n\"\"\"\n        Validates the given piece of data and converts it into its database representation\n        if validation was successful.\n        Arguments:\n            query: Query that matches the documents that will be updated.\n            data: The data to be inserted.\n        Returns:\n            The MongoDB-compatible, insertable data.\n        Raises:\n            Exception: if the data is invalid.\n        \"\"\"\nawait self._validate_insert(query, data)\nreturn await self._convert_for_insert(data)\nasync def _prepare_for_update(\nself, query: MongoQuery | None, data: TUpdate\n) -&gt; UpdateObject | Sequence[UpdateObject]:\n\"\"\"\n        Validates the given piece of data and converts it into an update object.\n        Arguments:\n            query: Query that matches the documents that will be updated.\n            data: The update data.\n        Returns:\n            The MongoDB-compatible update object.\n        Raises:\n            Exception: if the data is invalid.\n        \"\"\"\nawait self._validate_update(query, data)\nreturn await self._convert_for_update(data)\nasync def _validate_insert(self, query: MongoQuery | None, data: TInsert) -&gt; None:\n\"\"\"\n        Validates the given piece of data for insertion by executing all insert validators.\n        See `Validator` for more information.\n        Arguments:\n            query: Query that matches the documents that will be updated.\n            data: The data to validate.\n        Raises:\n            ValidationError: If validation failed.\n        \"\"\"\n# Sequential validation, slow but safe.\nfor validator in self._validators():\nif \"insert\" in validator.config:\nawait validator(self, query, data)\nasync def _validate_deny_delete(self, session: AgnosticClientSession, ids: Sequence[ObjectId]) -&gt; None:\n\"\"\"\n        Executes all \"deny\" delete rules.\n        See `DeleteRule` for more information.\n        Arguments:\n            session: The current database session.\n            ids: The IDs that will be removed.\n        Raises:\n            DeleteError: if one of the executed delete rules prevent the operation.\n        \"\"\"\nfor rule in self._delete_rules():\nif isinstance(rule, DeleteRule) and rule.config == \"deny\":\nawait rule(self, session, ids)\nasync def _validate_pre_delete(self, session: AgnosticClientSession, ids: Sequence[ObjectId]) -&gt; None:\n\"\"\"\n        Executes all \"pre\" delete rules.\n        See `DeleteRule` for more information.\n        Arguments:\n            session: The current database session.\n            ids: The IDs that will be removed.\n        Raises:\n            DeleteError: if one of the executed delete rules fail.\n        \"\"\"\nfor rule in self._delete_rules():\nif isinstance(rule, DeleteRule) and rule.config == \"pre\":\nawait rule(self, session, ids)\nasync def _validate_post_delete(self, session: AgnosticClientSession, ids: Sequence[ObjectId]) -&gt; None:\n\"\"\"\n        Executes all \"post\" delete rules.\n        See `DeleteRule` for more information.\n        Arguments:\n            session: The current database session.\n            ids: The IDs that will be removed.\n        Raises:\n            DeleteError: if one of the executed delete rules fail.\n        \"\"\"\nfor rule in self._delete_rules():\nif isinstance(rule, DeleteRule) and rule.config == \"post\":\nawait rule(self, session, ids)\nasync def _validate_update(self, query: MongoQuery | None, data: TUpdate) -&gt; None:\n\"\"\"\n        Validates the given piece of data for update by executing all update validators.\n        See `Validator` for more information.\n        Arguments:\n            query: Query that matches the documents that will be updated.\n            data: The data to validate.\n        Raises:\n            ValidationError: If validation failed.\n        \"\"\"\n# Sequential validation, slow but safe.\nfor validator in self._validators():\nif \"update\" in validator.config:\nawait validator(self, query, data)\ndef _validators(self) -&gt; Generator[Validator[\"MongoService[TInsert, TUpdate]\", TInsert | TUpdate], None, None]:\n\"\"\"\n        Generator that yields the validators that are registered on this service\n        in the order they are present in `__class__.__dict__`.\n        \"\"\"\nfor validator in self.__class__.__dict__.values():\nif isinstance(validator, Validator):\nyield validator\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService.client","title":"<code>client: AgnosticClient</code>  <code>property</code>","text":"<p>The database client.</p>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService.collection","title":"<code>collection: AgnosticCollection</code>  <code>property</code>","text":"<p>The collection instance of the service.</p>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService.collection_name","title":"<code>collection_name: str</code>  <code>instance-attribute</code>","text":"<p>The name of the collection the service operates on. Must be set by subclasses.</p>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService.collection_options","title":"<code>collection_options: CollectionOptions | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional <code>CollectionOptions</code> dict.</p>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService.indexes","title":"<code>indexes: dict[str, IndexData] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The full description of the indexes (if any) of the collection.</p>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService.__init__","title":"<code>__init__(database)</code>","text":"<p>Initialization.</p> <p>Parameters:</p> Name Type Description Default <code>database</code> <code>AgnosticDatabase</code> <p>The database driver.</p> required Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>def __init__(self, database: AgnosticDatabase) -&gt; None:\n\"\"\"\n    Initialization.\n    Arguments:\n        database: The database driver.\n    \"\"\"\nif self.collection_name is None:\nraise ValueError(\"MongoService.collection_name is not initialized.\")\nself._database = database\nself._collection: AgnosticCollection | None = None\nself._supports_transactions: bool | None = None\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService._convert_for_insert","title":"<code>_convert_for_insert(data)</code>  <code>async</code>","text":"<p>Converts the given piece of the into its database representation.</p> <p>The default implementation is simply <code>data.dict()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>TInsert</code> <p>The data to be inserted.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The MongoDB-compatible, insertable data.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if the data is invalid.</p> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>async def _convert_for_insert(self, data: TInsert) -&gt; dict[str, Any]:\n\"\"\"\n    Converts the given piece of the into its database representation.\n    The default implementation is simply `data.dict()`.\n    Arguments:\n        data: The data to be inserted.\n    Returns:\n        The MongoDB-compatible, insertable data.\n    Raises:\n        Exception: if the data is invalid.\n    \"\"\"\nreturn data.dict()\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService._convert_for_update","title":"<code>_convert_for_update(data)</code>  <code>async</code>","text":"<p>Converts the given piece of data into an update object.</p> <p>The default implementation is <code>{\"$set\": data.dict(exclude_unset=True)}</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>TUpdate</code> <p>The update data.</p> required <p>Returns:</p> Type Description <code>UpdateObject | Sequence[UpdateObject]</code> <p>The MongoDB-compatible update object.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if the data is invalid.</p> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>async def _convert_for_update(self, data: TUpdate) -&gt; UpdateObject | Sequence[UpdateObject]:\n\"\"\"\n    Converts the given piece of data into an update object.\n    The default implementation is `{\"$set\": data.dict(exclude_unset=True)}`.\n    Arguments:\n        data: The update data.\n    Returns:\n        The MongoDB-compatible update object.\n    Raises:\n        Exception: if the data is invalid.\n    \"\"\"\nreturn {\"$set\": data.dict(exclude_unset=True)}\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService._create_collection","title":"<code>_create_collection()</code>","text":"<p>Creates a new <code>AgnosticCollection</code> instance for the service.</p> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>def _create_collection(self) -&gt; AgnosticCollection:\n\"\"\"\n    Creates a new `AgnosticCollection` instance for the service.\n    \"\"\"\nreturn self._database.get_collection(self.collection_name, **(self.collection_options or {}))\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService._delete_rules","title":"<code>_delete_rules()</code>","text":"<p>Generator that yields the delete rules that are registered on this service in the order they are present in <code>__class__.__dict__</code>.</p> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>def _delete_rules(self) -&gt; Generator[DeleteRule[\"MongoService[TInsert, TUpdate]\"], None, None]:\n\"\"\"\n    Generator that yields the delete rules that are registered on this service\n    in the order they are present in `__class__.__dict__`.\n    \"\"\"\nfor rule in self.__class__.__dict__.values():\nif isinstance(rule, DeleteRule):\nyield rule\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService._get_session_context_manager","title":"<code>_get_session_context_manager(session)</code>","text":"<p>Returns a session context manager</p> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>def _get_session_context_manager(\nself,\nsession: AgnosticClientSession | None,\n) -&gt; Callable[[], Coroutine[None, None, AbstractAsyncContextManager[AgnosticClientSession]]]:\n\"\"\"\n    Returns a session context manager\n    \"\"\"\nif session is None:\n# Return a context manager that actually starts a session.\nreturn self.client.start_session  # type: ignore[no-any-return]\nasync def start_session() -&gt; AbstractAsyncContextManager[AgnosticClientSession]:\n@asynccontextmanager\nasync def ctx_manager() -&gt; AsyncGenerator[AgnosticClientSession, None]:\nyield session\nreturn ctx_manager()\nreturn start_session\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService._has_delete_rules","title":"<code>_has_delete_rules()</code>","text":"<p>Returns whether the service has any delete rules.</p> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>def _has_delete_rules(self) -&gt; bool:\n\"\"\"\n    Returns whether the service has any delete rules.\n    \"\"\"\nfor rule in self.__class__.__dict__.values():\nif isinstance(rule, DeleteRule):\nreturn True\nreturn False\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService._prepare_for_insert","title":"<code>_prepare_for_insert(query, data)</code>  <code>async</code>","text":"<p>Validates the given piece of data and converts it into its database representation if validation was successful.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>MongoQuery | None</code> <p>Query that matches the documents that will be updated.</p> required <code>data</code> <code>TInsert</code> <p>The data to be inserted.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The MongoDB-compatible, insertable data.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if the data is invalid.</p> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>async def _prepare_for_insert(self, query: MongoQuery | None, data: TInsert) -&gt; dict[str, Any]:\n\"\"\"\n    Validates the given piece of data and converts it into its database representation\n    if validation was successful.\n    Arguments:\n        query: Query that matches the documents that will be updated.\n        data: The data to be inserted.\n    Returns:\n        The MongoDB-compatible, insertable data.\n    Raises:\n        Exception: if the data is invalid.\n    \"\"\"\nawait self._validate_insert(query, data)\nreturn await self._convert_for_insert(data)\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService._prepare_for_update","title":"<code>_prepare_for_update(query, data)</code>  <code>async</code>","text":"<p>Validates the given piece of data and converts it into an update object.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>MongoQuery | None</code> <p>Query that matches the documents that will be updated.</p> required <code>data</code> <code>TUpdate</code> <p>The update data.</p> required <p>Returns:</p> Type Description <code>UpdateObject | Sequence[UpdateObject]</code> <p>The MongoDB-compatible update object.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if the data is invalid.</p> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>async def _prepare_for_update(\nself, query: MongoQuery | None, data: TUpdate\n) -&gt; UpdateObject | Sequence[UpdateObject]:\n\"\"\"\n    Validates the given piece of data and converts it into an update object.\n    Arguments:\n        query: Query that matches the documents that will be updated.\n        data: The update data.\n    Returns:\n        The MongoDB-compatible update object.\n    Raises:\n        Exception: if the data is invalid.\n    \"\"\"\nawait self._validate_update(query, data)\nreturn await self._convert_for_update(data)\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService._validate_deny_delete","title":"<code>_validate_deny_delete(session, ids)</code>  <code>async</code>","text":"<p>Executes all \"deny\" delete rules.</p> <p>See <code>DeleteRule</code> for more information.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AgnosticClientSession</code> <p>The current database session.</p> required <code>ids</code> <code>Sequence[ObjectId]</code> <p>The IDs that will be removed.</p> required <p>Raises:</p> Type Description <code>DeleteError</code> <p>if one of the executed delete rules prevent the operation.</p> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>async def _validate_deny_delete(self, session: AgnosticClientSession, ids: Sequence[ObjectId]) -&gt; None:\n\"\"\"\n    Executes all \"deny\" delete rules.\n    See `DeleteRule` for more information.\n    Arguments:\n        session: The current database session.\n        ids: The IDs that will be removed.\n    Raises:\n        DeleteError: if one of the executed delete rules prevent the operation.\n    \"\"\"\nfor rule in self._delete_rules():\nif isinstance(rule, DeleteRule) and rule.config == \"deny\":\nawait rule(self, session, ids)\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService._validate_insert","title":"<code>_validate_insert(query, data)</code>  <code>async</code>","text":"<p>Validates the given piece of data for insertion by executing all insert validators.</p> <p>See <code>Validator</code> for more information.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>MongoQuery | None</code> <p>Query that matches the documents that will be updated.</p> required <code>data</code> <code>TInsert</code> <p>The data to validate.</p> required <p>Raises:</p> Type Description <code>ValidationError</code> <p>If validation failed.</p> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>async def _validate_insert(self, query: MongoQuery | None, data: TInsert) -&gt; None:\n\"\"\"\n    Validates the given piece of data for insertion by executing all insert validators.\n    See `Validator` for more information.\n    Arguments:\n        query: Query that matches the documents that will be updated.\n        data: The data to validate.\n    Raises:\n        ValidationError: If validation failed.\n    \"\"\"\n# Sequential validation, slow but safe.\nfor validator in self._validators():\nif \"insert\" in validator.config:\nawait validator(self, query, data)\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService._validate_post_delete","title":"<code>_validate_post_delete(session, ids)</code>  <code>async</code>","text":"<p>Executes all \"post\" delete rules.</p> <p>See <code>DeleteRule</code> for more information.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AgnosticClientSession</code> <p>The current database session.</p> required <code>ids</code> <code>Sequence[ObjectId]</code> <p>The IDs that will be removed.</p> required <p>Raises:</p> Type Description <code>DeleteError</code> <p>if one of the executed delete rules fail.</p> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>async def _validate_post_delete(self, session: AgnosticClientSession, ids: Sequence[ObjectId]) -&gt; None:\n\"\"\"\n    Executes all \"post\" delete rules.\n    See `DeleteRule` for more information.\n    Arguments:\n        session: The current database session.\n        ids: The IDs that will be removed.\n    Raises:\n        DeleteError: if one of the executed delete rules fail.\n    \"\"\"\nfor rule in self._delete_rules():\nif isinstance(rule, DeleteRule) and rule.config == \"post\":\nawait rule(self, session, ids)\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService._validate_pre_delete","title":"<code>_validate_pre_delete(session, ids)</code>  <code>async</code>","text":"<p>Executes all \"pre\" delete rules.</p> <p>See <code>DeleteRule</code> for more information.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AgnosticClientSession</code> <p>The current database session.</p> required <code>ids</code> <code>Sequence[ObjectId]</code> <p>The IDs that will be removed.</p> required <p>Raises:</p> Type Description <code>DeleteError</code> <p>if one of the executed delete rules fail.</p> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>async def _validate_pre_delete(self, session: AgnosticClientSession, ids: Sequence[ObjectId]) -&gt; None:\n\"\"\"\n    Executes all \"pre\" delete rules.\n    See `DeleteRule` for more information.\n    Arguments:\n        session: The current database session.\n        ids: The IDs that will be removed.\n    Raises:\n        DeleteError: if one of the executed delete rules fail.\n    \"\"\"\nfor rule in self._delete_rules():\nif isinstance(rule, DeleteRule) and rule.config == \"pre\":\nawait rule(self, session, ids)\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService._validate_update","title":"<code>_validate_update(query, data)</code>  <code>async</code>","text":"<p>Validates the given piece of data for update by executing all update validators.</p> <p>See <code>Validator</code> for more information.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>MongoQuery | None</code> <p>Query that matches the documents that will be updated.</p> required <code>data</code> <code>TUpdate</code> <p>The data to validate.</p> required <p>Raises:</p> Type Description <code>ValidationError</code> <p>If validation failed.</p> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>async def _validate_update(self, query: MongoQuery | None, data: TUpdate) -&gt; None:\n\"\"\"\n    Validates the given piece of data for update by executing all update validators.\n    See `Validator` for more information.\n    Arguments:\n        query: Query that matches the documents that will be updated.\n        data: The data to validate.\n    Raises:\n        ValidationError: If validation failed.\n    \"\"\"\n# Sequential validation, slow but safe.\nfor validator in self._validators():\nif \"update\" in validator.config:\nawait validator(self, query, data)\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService._validators","title":"<code>_validators()</code>","text":"<p>Generator that yields the validators that are registered on this service in the order they are present in <code>__class__.__dict__</code>.</p> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>def _validators(self) -&gt; Generator[Validator[\"MongoService[TInsert, TUpdate]\", TInsert | TUpdate], None, None]:\n\"\"\"\n    Generator that yields the validators that are registered on this service\n    in the order they are present in `__class__.__dict__`.\n    \"\"\"\nfor validator in self.__class__.__dict__.values():\nif isinstance(validator, Validator):\nyield validator\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService.aggregate","title":"<code>aggregate(pipeline, session=None, **kwargs)</code>","text":"<p>Performs an aggregation.</p> <p>For undocumented keyword arguments, see the documentation of <code>pymongo.collection.Collection.aggregate()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>pipeline</code> <code>Sequence[dict[str, Any]]</code> <p>The aggregation pipeline.</p> required <code>session</code> <code>AgnosticClientSession | None</code> <p>An optional session to use.</p> <code>None</code> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>def aggregate(\nself,\npipeline: Sequence[dict[str, Any]],\nsession: AgnosticClientSession | None = None,\n**kwargs: Any,\n) -&gt; AgnosticLatentCommandCursor:\n\"\"\"\n    Performs an aggregation.\n    For undocumented keyword arguments, see the documentation of `pymongo.collection.Collection.aggregate()`.\n    Arguments:\n        pipeline: The aggregation pipeline.\n        session: An optional session to use.\n    \"\"\"\nreturn self.collection.aggregate(pipeline, session=session, **kwargs)\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService.count_documents","title":"<code>count_documents(query, *, options=None)</code>  <code>async</code>","text":"<p>Returns the number of documents that match the given query.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>MongoQuery</code> <p>The query object.</p> required <code>options</code> <code>FindOptions | None</code> <p>Query options, see the arguments of <code>collection.count_documents()</code> for details.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of matching documents.</p> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>async def count_documents(self, query: MongoQuery, *, options: FindOptions | None = None) -&gt; int:\n\"\"\"\n    Returns the number of documents that match the given query.\n    Arguments:\n        query: The query object.\n        options: Query options, see the arguments of `collection.count_documents()` for details.\n    Returns:\n        The number of matching documents.\n    \"\"\"\nreturn await self.collection.count_documents(query, **(options or {}))  # type: ignore[no-any-return]\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService.create_index","title":"<code>create_index(keys, *, name, unique=False, session=None, background=False, collation=None, sparse=False, **kwargs)</code>  <code>async</code>","text":"<p>Creates the specified index on collection of the service.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>str | Sequence[tuple[str, int | str | Mapping[str, Any]]]</code> <p>Index description.</p> required <code>name</code> <code>str</code> <p>Index name.</p> required <code>unique</code> <code>bool</code> <p>Whether to create a uniqueness constraint on the index.</p> <code>False</code> <code>session</code> <code>AgnosticClientSession | None</code> <p>An optional session to use.</p> <code>None</code> <code>background</code> <code>bool</code> <p>Whether the index should be created in the background.</p> <code>False</code> <code>collation</code> <code>Collation | None</code> <p>A <code>Collation</code> instance.</p> <code>None</code> <code>sparse</code> <code>bool</code> <p>Whether to omit documents from the index that doesn't have the indexed field.</p> <code>False</code> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>async def create_index(\nself,\nkeys: str | Sequence[tuple[str, int | str | Mapping[str, Any]]],\n*,\nname: str,\nunique: bool = False,\nsession: AgnosticClientSession | None = None,\nbackground: bool = False,\ncollation: Collation | None = None,\nsparse: bool = False,\n**kwargs: Any,\n) -&gt; str:\n\"\"\"\n    Creates the specified index on collection of the service.\n    Arguments:\n        keys: Index description.\n        name: Index name.\n        unique: Whether to create a uniqueness constraint on the index.\n        session: An optional session to use.\n        background: Whether the index should be created in the background.\n        collation: A `Collation` instance.\n        sparse: Whether to omit documents from the index that doesn't have the indexed field.\n    \"\"\"\nreturn await self.collection.create_index(  # type: ignore[no-any-return]\nkeys,\nname=name,\nunique=unique,\nsession=session,\nbackground=background,\ncollation=collation,\nsparse=sparse,\n**kwargs,\n)\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService.create_indexes","title":"<code>create_indexes(session=None)</code>  <code>async</code>","text":"<p>Creates all declared indexes (see cls.indexes) on the collection of the service.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AgnosticClientSession | None</code> <p>An optional session to use.</p> <code>None</code> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>async def create_indexes(self, session: AgnosticClientSession | None = None) -&gt; None:\n\"\"\"\n    Creates all declared indexes (see cls.indexes) on the collection of the service.\n    Arguments:\n        session: An optional session to use.\n    \"\"\"\nif self.indexes is None:\nreturn\nfor name, idx in self.indexes.items():\nawait self.create_index(\nidx.keys,\nname=name,\nunique=idx.unique,\nbackground=idx.background,\ncollation=idx.collation,\nsparse=idx.sparse,\nsession=session,\n**idx.extra,\n)\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService.delete_by_id","title":"<code>delete_by_id(id, *, options=None)</code>  <code>async</code>","text":"<p>Deletes the document with the given ID.</p> <p>This method is just a convenience wrapper around <code>delete_one()</code>, see that method for more details.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>ObjectId</code> <p>The ID of the document to delete.</p> required <code>options</code> <code>DeleteOptions | None</code> <p>Delete options, see the arguments of <code>collection.delete_one()</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>DeleteResult</code> <p>The result of the operation.</p> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>async def delete_by_id(\nself,\nid: ObjectId,\n*,\noptions: DeleteOptions | None = None,\n) -&gt; DeleteResult:\n\"\"\"\n    Deletes the document with the given ID.\n    This method is just a convenience wrapper around `delete_one()`, see that\n    method for more details.\n    Arguments:\n        id: The ID of the document to delete.\n        options: Delete options, see the arguments of `collection.delete_one()`.\n    Returns:\n        The result of the operation.\n    \"\"\"\nreturn await self.delete_one({\"_id\": id}, options=options)\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService.delete_many","title":"<code>delete_many(query, *, options=None)</code>  <code>async</code>","text":"<p>The default <code>delete_many()</code> implementation of the service.</p> <p>The method enforces delete rules and executes the operation as follows:</p> <ol> <li>Enforce <code>\"deny\"</code> delete rules.</li> <li>Enforce <code>\"pre\"</code> delete rules.</li> <li>Execute the delete operation.</li> <li>Enforce <code>\"post\"</code> delete rules.</li> </ol> <p>See <code>DeleteRule</code> for more information.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>MongoQuery | None</code> <p>Query object that matches the documents that should be deleted.</p> required <code>options</code> <code>DeleteOptions | None</code> <p>Delete options, see the arguments of <code>collection.delete_many()</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>DeleteResult</code> <p>The result of the operation.</p> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>async def delete_many(\nself,\nquery: MongoQuery | None,\n*,\noptions: DeleteOptions | None = None,\n) -&gt; DeleteResult:\n\"\"\"\n    The default `delete_many()` implementation of the service.\n    The method enforces delete rules and executes the operation as follows:\n    1. Enforce `\"deny\"` delete rules.\n    2. Enforce `\"pre\"` delete rules.\n    3. Execute the delete operation.\n    4. Enforce `\"post\"` delete rules.\n    See `DeleteRule` for more information.\n    Arguments:\n        query: Query object that matches the documents that should be deleted.\n        options: Delete options, see the arguments of `collection.delete_many()`.\n    Returns:\n        The result of the operation.\n    \"\"\"\nsession_manager = self._get_session_context_manager(options.get(\"session\", None) if options else None)\nasync with await session_manager() as session:\nopts: DeleteOptions = options or {}\nopts[\"session\"] = session\nctxman = (\nnullcontext\nif session.in_transaction or not await self.supports_transactions()\nelse session.start_transaction\n)\nids: list[ObjectId] | None = (\nawait self.find_ids(query, session=session) if self._has_delete_rules() else None\n)\nhas_ids = ids is not None and len(ids) &gt; 0\nasync with ctxman():\nif has_ids:\nawait self._validate_deny_delete(\nsession,\nids,  # type: ignore[arg-type] # can not be None if has_ids is True\n)\nawait self._validate_pre_delete(\nsession,\nids,  # type: ignore[arg-type] # can not be None if has_ids is True\n)\nresult = await self.collection.delete_many(query, **opts)\nif has_ids:\nawait self._validate_post_delete(\nsession,\nids,  # type: ignore[arg-type] # can not be None if has_ids is True\n)\nreturn result  # type: ignore[no-any-return]\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService.delete_one","title":"<code>delete_one(query, *, options=None)</code>  <code>async</code>","text":"<p>The default <code>delete_one()</code> implementation of the service.</p> <p>The method enforces delete rules and executes the operation as follows:</p> <ol> <li>Enforce <code>\"deny\"</code> delete rules.</li> <li>Enforce <code>\"pre\"</code> delete rules.</li> <li>Execute the delete operation.</li> <li>Enforce <code>\"post\"</code> delete rules.</li> </ol> <p>See <code>DeleteRule</code> for more information.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>MongoQuery | None</code> <p>Query object that matches the document that should be deleted.</p> required <code>options</code> <code>DeleteOptions | None</code> <p>Delete options, see the arguments of <code>collection.delete_one()</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>DeleteResult</code> <p>The result of the operation.</p> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>async def delete_one(\nself,\nquery: MongoQuery | None,\n*,\noptions: DeleteOptions | None = None,\n) -&gt; DeleteResult:\n\"\"\"\n    The default `delete_one()` implementation of the service.\n    The method enforces delete rules and executes the operation as follows:\n    1. Enforce `\"deny\"` delete rules.\n    2. Enforce `\"pre\"` delete rules.\n    3. Execute the delete operation.\n    4. Enforce `\"post\"` delete rules.\n    See `DeleteRule` for more information.\n    Arguments:\n        query: Query object that matches the document that should be deleted.\n        options: Delete options, see the arguments of `collection.delete_one()`.\n    Returns:\n        The result of the operation.\n    \"\"\"\nsession_manager = self._get_session_context_manager(options.get(\"session\", None) if options else None)\nasync with await session_manager() as session:\nopts: DeleteOptions = options or {}\nopts[\"session\"] = session\nctxman = (\nnullcontext\nif session.in_transaction or not await self.supports_transactions()\nelse session.start_transaction\n)\nids: list[ObjectId] | None = (\nawait self.find_ids(query, session=session) if self._has_delete_rules() else None\n)\nasync with ctxman():\nif ids is not None:\nif len(ids) &gt; 1:\n# Only when the service has delete rules...\nraise ValueError(\"Ambigous delete_one() - multiple documents match the query.\")\nawait self._validate_deny_delete(session, ids)\nawait self._validate_pre_delete(session, ids)\nresult = await self.collection.delete_one(query, **opts)\nif ids is not None:\nawait self._validate_post_delete(session, ids)\nreturn result  # type: ignore[no-any-return]\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService.drop_index","title":"<code>drop_index(index_or_name, session=None, **kwargs)</code>  <code>async</code>","text":"<p>Drops the given index from the collection of the service.</p> <p>Parameters:</p> Name Type Description Default <code>index_or_name</code> <code>str | Sequence[tuple[str, int | str | Mapping[str, Any]]]</code> <p>The index to drop.</p> required <code>session</code> <code>AgnosticClientSession | None</code> <p>An optional session to use.</p> <code>None</code> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>async def drop_index(\nself,\nindex_or_name: str | Sequence[tuple[str, int | str | Mapping[str, Any]]],\nsession: AgnosticClientSession | None = None,\n**kwargs: Any,\n) -&gt; None:\n\"\"\"\n    Drops the given index from the collection of the service.\n    Arguments:\n        index_or_name: The index to drop.\n        session: An optional session to use.\n    \"\"\"\nreturn await self.collection.drop_index(  # type: ignore[no-any-return]\nindex_or_name,\nsession=session,\n**kwargs,\n)\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService.drop_indexes","title":"<code>drop_indexes(session=None, **kwargs)</code>  <code>async</code>","text":"<p>Drops all indexes from the collection of the service.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AgnosticClientSession | None</code> <p>An optional session to use.</p> <code>None</code> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>async def drop_indexes(self, session: AgnosticClientSession | None = None, **kwargs: Any) -&gt; None:\n\"\"\"\n    Drops all indexes from the collection of the service.\n    Arguments:\n        session: An optional session to use.\n    \"\"\"\nreturn await self.collection.drop_indexes(session, **kwargs)  # type: ignore[no-any-return]\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService.exists","title":"<code>exists(id, *, options=None)</code>  <code>async</code>","text":"<p>Returns whether the document with the given ID exists.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>ObjectId</code> <p>The ID of the document to check.</p> required <code>options</code> <code>FindOptions | None</code> <p>Query options, see the arguments of <code>collection.count_documents()</code> for details.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the document with the given ID exists.</p> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>async def exists(self, id: ObjectId, *, options: FindOptions | None = None) -&gt; bool:\n\"\"\"\n    Returns whether the document with the given ID exists.\n    Arguments:\n        id: The ID of the document to check.\n        options: Query options, see the arguments of `collection.count_documents()` for details.\n    Returns:\n        Whether the document with the given ID exists.\n    \"\"\"\nreturn await self.count_documents({\"_id\": id}, options=options) == 1\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService.find","title":"<code>find(query=None, projection=None, *, options=None)</code>","text":"<p>The default <code>find()</code> implementation of the service.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>MongoQuery | None</code> <p>The query object.</p> <code>None</code> <code>projection</code> <code>MongoProjection | None</code> <p>Optional projection.</p> <code>None</code> <code>options</code> <code>FindOptions | None</code> <p>Query options, see the arguments of <code>collection.find()</code> for details.</p> <code>None</code> <p>Returns:</p> Type Description <code>AgnosticCursor</code> <p>An async database cursor.</p> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>def find(\nself,\nquery: MongoQuery | None = None,\nprojection: MongoProjection | None = None,\n*,\noptions: FindOptions | None = None,\n) -&gt; AgnosticCursor:\n\"\"\"\n    The default `find()` implementation of the service.\n    Arguments:\n        query: The query object.\n        projection: Optional projection.\n        options: Query options, see the arguments of `collection.find()` for details.\n    Returns:\n        An async database cursor.\n    \"\"\"\nreturn self.collection.find(query, projection, **(options or {}))\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService.find_ids","title":"<code>find_ids(query, *, session=None)</code>  <code>async</code>","text":"<p>Returns the IDs of all documents that match the given query.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>MongoQuery | None</code> <p>The query object.</p> required <code>session</code> <code>AgnosticClientSession | None</code> <p>An optional database session to use.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[ObjectId]</code> <p>The IDs of all matching documents.</p> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>async def find_ids(\nself,\nquery: MongoQuery | None,\n*,\nsession: AgnosticClientSession | None = None,\n) -&gt; list[ObjectId]:\n\"\"\"\n    Returns the IDs of all documents that match the given query.\n    Arguments:\n        query: The query object.\n        session: An optional database session to use.\n    Returns:\n        The IDs of all matching documents.\n    \"\"\"\nreturn [doc[\"_id\"] for doc in await self.collection.find(query, {\"_id\": True}, session=session).to_list(None)]\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService.find_one","title":"<code>find_one(query=None, projection=None, *, options=None)</code>  <code>async</code>","text":"<p>The default <code>find_one()</code> implementation of the service.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>MongoQuery | None</code> <p>The query object.</p> <code>None</code> <code>projection</code> <code>MongoProjection | None</code> <p>Optional projection.</p> <code>None</code> <code>options</code> <code>FindOptions | None</code> <p>Query options, see the arguments of <code>collection.find()</code> for details.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>A single matching document or <code>None</code> if there are no matches.</p> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>async def find_one(\nself,\nquery: MongoQuery | None = None,\nprojection: MongoProjection | None = None,\n*,\noptions: FindOptions | None = None,\n) -&gt; dict[str, Any] | None:\n\"\"\"\n    The default `find_one()` implementation of the service.\n    Arguments:\n        query: The query object.\n        projection: Optional projection.\n        options: Query options, see the arguments of `collection.find()` for details.\n    Returns:\n        A single matching document or `None` if there are no matches.\n    \"\"\"\nreturn await self.collection.find_one(query, projection, **(options or {}))  # type: ignore[no-any-return]\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService.get_by_id","title":"<code>get_by_id(id, projection=None, *, options=None)</code>  <code>async</code>","text":"<p>Returns the document with the given ID if it exists.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>ObjectId</code> <p>The ID of the queried document. Must be an <code>ObjectID</code>, not a <code>str</code>.</p> required <code>projection</code> <code>MongoProjection | None</code> <p>Optional projection.</p> <code>None</code> <code>options</code> <code>FindOptions | None</code> <p>Query options, see the arguments of <code>collection.find()</code> for details.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>The queried document if such a document exists.</p> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>async def get_by_id(\nself,\nid: ObjectId,\nprojection: MongoProjection | None = None,\n*,\noptions: FindOptions | None = None,\n) -&gt; dict[str, Any] | None:\n\"\"\"\n    Returns the document with the given ID if it exists.\n    Arguments:\n        id: The ID of the queried document. Must be an `ObjectID`, not a `str`.\n        projection: Optional projection.\n        options: Query options, see the arguments of `collection.find()` for details.\n    Returns:\n        The queried document if such a document exists.\n    \"\"\"\nreturn await self.find_one({\"_id\": id}, projection, options=options)\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService.insert_one","title":"<code>insert_one(data, *, options=None)</code>  <code>async</code>","text":"<p>Inserts the given data into the collection.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>TInsert</code> <p>The data to be inserted.</p> required <code>options</code> <code>InsertOneOptions | None</code> <p>Insert options, see the arguments of <code>collection.insert_one()</code> for details.</p> <code>None</code> <p>Returns:</p> Type Description <code>InsertOneResult</code> <p>The result of the operation.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if the data is invalid.</p> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>async def insert_one(self, data: TInsert, *, options: InsertOneOptions | None = None) -&gt; InsertOneResult:\n\"\"\"\n    Inserts the given data into the collection.\n    Arguments:\n        data: The data to be inserted.\n        options: Insert options, see the arguments of `collection.insert_one()` for details.\n    Returns:\n        The result of the operation.\n    Raises:\n        Exception: if the data is invalid.\n    \"\"\"\nreturn await self.collection.insert_one(  # type: ignore[no-any-return]\nawait self._prepare_for_insert(None, data),\n**(options or {}),\n)\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService.list_indexes","title":"<code>list_indexes(session=None, **kwargs)</code>","text":"<p>Returns a cursor over the indexes of the collection of the service.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AgnosticClientSession | None</code> <p>An optional session to use.</p> <code>None</code> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>def list_indexes(\nself,\nsession: AgnosticClientSession | None = None,\n**kwargs: Any,\n) -&gt; AgnosticLatentCommandCursor:\n\"\"\"\n    Returns a cursor over the indexes of the collection of the service.\n    Arguments:\n        session: An optional session to use.\n    \"\"\"\nreturn self.collection.list_indexes(session, **kwargs)\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService.supports_transactions","title":"<code>supports_transactions()</code>  <code>async</code>","text":"<p>Queries the database if it supports transactions or not.</p> <p>Note: transactions are only supported in replica set configuration.</p> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>async def supports_transactions(self) -&gt; bool:\n\"\"\"\n    Queries the database if it supports transactions or not.\n    Note: transactions are only supported in replica set configuration.\n    \"\"\"\nif self._supports_transactions is None:\nself._supports_transactions = \"system.replset\" in (await self.client[\"local\"].list_collection_names())\nreturn self._supports_transactions\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService.update_by_id","title":"<code>update_by_id(id, changes, *, options=None)</code>  <code>async</code>","text":"<p>Updates the document with the given ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>ObjectId</code> <p>The ID of the document to update.</p> required <code>changes</code> <code>TUpdate</code> <p>The changes to make.</p> required <code>options</code> <code>UpdateOneOptions | None</code> <p>Update options, see the arguments of <code>collection.update_one()</code> for details.</p> <code>None</code> <p>Returns:</p> Type Description <code>UpdateResult</code> <p>The result of the operation.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if the data is invalid.</p> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>async def update_by_id(\nself,\nid: ObjectId,\nchanges: TUpdate,\n*,\noptions: UpdateOneOptions | None = None,\n) -&gt; UpdateResult:\n\"\"\"\n    Updates the document with the given ID.\n    Arguments:\n        id: The ID of the document to update.\n        changes: The changes to make.\n        options: Update options, see the arguments of `collection.update_one()` for details.\n    Returns:\n        The result of the operation.\n    Raises:\n        Exception: if the data is invalid.\n    \"\"\"\nreturn await self.update_one({\"_id\": id}, changes, options=options)\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService.update_many","title":"<code>update_many(query, changes, *, options=None)</code>  <code>async</code>","text":"<p>The default <code>delete_many()</code> implementation of the service.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>MongoQuery | None</code> <p>Query that matches the documents that should be updated.</p> required <code>changes</code> <code>TUpdate</code> <p>The changes to make.</p> required <code>options</code> <code>UpdateManyOptions | None</code> <p>Update options, see the arguments of <code>collection.update_many()</code> for details.</p> <code>None</code> <p>Returns:</p> Type Description <code>UpdateResult</code> <p>The result of the operation.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if the data is invalid.</p> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>async def update_many(\nself,\nquery: MongoQuery | None,\nchanges: TUpdate,\n*,\noptions: UpdateManyOptions | None = None,\n) -&gt; UpdateResult:\n\"\"\"\n    The default `delete_many()` implementation of the service.\n    Arguments:\n        query: Query that matches the documents that should be updated.\n        changes: The changes to make.\n        options: Update options, see the arguments of `collection.update_many()` for details.\n    Returns:\n        The result of the operation.\n    Raises:\n        Exception: if the data is invalid.\n    \"\"\"\nreturn await self.collection.update_many(  # type: ignore[no-any-return]\nquery,\nawait self._prepare_for_update(query, changes),\n**(options or {}),\n)\n</code></pre>"},{"location":"api-service/#fastapi_motor_oil.service.MongoService.update_one","title":"<code>update_one(query, changes, *, options=None)</code>  <code>async</code>","text":"<p>The default <code>delete_one()</code> implementation of the service.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>MongoQuery | None</code> <p>Query that matches the document that should be updated.</p> required <code>changes</code> <code>TUpdate</code> <p>The changes to make.</p> required <code>options</code> <code>UpdateOneOptions | None</code> <p>Update options, see the arguments of <code>collection.update_one()</code> for details.</p> <code>None</code> <p>Returns:</p> Type Description <code>UpdateResult</code> <p>The result of the operation.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if the data is invalid.</p> Source code in <code>fastapi_motor_oil/service.py</code> <pre><code>async def update_one(\nself,\nquery: MongoQuery | None,\nchanges: TUpdate,\n*,\noptions: UpdateOneOptions | None = None,\n) -&gt; UpdateResult:\n\"\"\"\n    The default `delete_one()` implementation of the service.\n    Arguments:\n        query: Query that matches the document that should be updated.\n        changes: The changes to make.\n        options: Update options, see the arguments of `collection.update_one()` for details.\n    Returns:\n        The result of the operation.\n    Raises:\n        Exception: if the data is invalid.\n    \"\"\"\nreturn await self.collection.update_one(  # type: ignore[no-any-return]\nquery,\nawait self._prepare_for_update(query, changes),\n**(options or {}),\n)\n</code></pre>"},{"location":"api-typing/","title":"Helper types","text":""},{"location":"api-typing/#fastapi_motor_oil.typing.MongoProjection","title":"<code>MongoProjection = dict[str, Any]</code>  <code>module-attribute</code>","text":"<p>MongoDB projection object.</p>"},{"location":"api-typing/#fastapi_motor_oil.typing.MongoQuery","title":"<code>MongoQuery = dict[str, Any]</code>  <code>module-attribute</code>","text":"<p>MongoDB query object.</p>"},{"location":"api-typing/#fastapi_motor_oil.typing.UpdateObject","title":"<code>UpdateObject = dict[str, Any] | Sequence[dict[str, Any]]</code>  <code>module-attribute</code>","text":"<p>MongoDB update object.</p>"},{"location":"api-typing/#fastapi_motor_oil.typing.CollationDict","title":"<code>CollationDict</code>","text":"<p>             Bases: <code>TypedDict</code></p> <p>Collation definition as a dict.</p> Source code in <code>fastapi_motor_oil/typing.py</code> <pre><code>class CollationDict(TypedDict, total=False):\n\"\"\"\n    Collation definition as a dict.\n    \"\"\"\nlocale: str\ncaseLevel: bool | None\ncaseFirst: str | None\nstrength: int | None\nnumericOrdering: bool | None\nalternate: str | None\nmaxVariable: str | None\nnormalization: bool | None\nbackwards: bool | None\n</code></pre>"},{"location":"api-typing/#fastapi_motor_oil.typing.CollectionOptions","title":"<code>CollectionOptions</code>","text":"<p>             Bases: <code>TypedDict</code></p> <p>Collection options.</p> Source code in <code>fastapi_motor_oil/typing.py</code> <pre><code>class CollectionOptions(TypedDict, total=False):\n\"\"\"\n    Collection options.\n    \"\"\"\ncodec_options: \"CodecOptions[Any]\" | None  # Default is None\nread_preference: Primary | PrimaryPreferred | Secondary | SecondaryPreferred | Nearest | None  # Default  None\nwrite_concern: WriteConcern | None  # Default is None\nread_concern: ReadConcern | None  # Default is None\n</code></pre>"},{"location":"api-typing/#fastapi_motor_oil.typing.DeleteOptions","title":"<code>DeleteOptions</code>","text":"<p>             Bases: <code>TypedDict</code></p> <p>Delete options.</p> Source code in <code>fastapi_motor_oil/typing.py</code> <pre><code>class DeleteOptions(TypedDict, total=False):\n\"\"\"\n    Delete options.\n    \"\"\"\ncollation: Mapping[str, Any] | Collation | None  # Default is None\nhint: str | Sequence[tuple[str, int | str | Mapping[str, Any]]] | None  # Default is None\nsession: AgnosticCollection | None  # Default is None\nlet: Mapping[str, Any] | None  # Default is None\ncomment: Any | None  # Default is None\n</code></pre>"},{"location":"api-typing/#fastapi_motor_oil.typing.FindOptions","title":"<code>FindOptions</code>","text":"<p>             Bases: <code>TypedDict</code></p> <p>Find options.</p> Source code in <code>fastapi_motor_oil/typing.py</code> <pre><code>class FindOptions(TypedDict, total=False):\n\"\"\"\n    Find options.\n    \"\"\"\nskip: int  # Default is 0\nlimit: int  # Default is 0\nno_cursor_timeout: bool  # Default is False\ncursor_type: int  # Default is pymongo.cursor.CursorType.NON_TAILABLE\nsort: Sequence[tuple[str, int | str | Mapping[str, Any]]] | None  # Default is None\nallow_partial_results: bool  # Default is False\noplog_replay: bool  # Default is False\nbatch_size: int  # Default is 0\ncollation: Mapping[str, Any] | Collation | None  # Default is None\nhint: str | Sequence[tuple[str, int | str | Mapping[str, Any]]] | None  # Default is None\nmax_scan: int | None  # Default is None\nmax_time_ms: int | None  # Default is None\nmax: Sequence[tuple[str, int | str | Mapping[str, Any]]] | None  # Default is None\nmin: Sequence[tuple[str, int | str | Mapping[str, Any]]] | None  # Default is None\nreturn_key: bool | None  # Default is None\nshow_record_id: bool | None  # Default is None\nsnapshot: bool | None  # Default is None\ncomment: Any | None  # Default is None\nsession: AgnosticCollection | None  # Default is None\nallow_disk_use: bool | None  # Default is None\nlet: bool | None  # Default is None\n</code></pre>"},{"location":"api-typing/#fastapi_motor_oil.typing.IndexData","title":"<code>IndexData</code>  <code>dataclass</code>","text":"<p>Index data description.</p> Source code in <code>fastapi_motor_oil/typing.py</code> <pre><code>@dataclass(frozen=True, kw_only=True, slots=True)\nclass IndexData:\n\"\"\"\n    Index data description.\n    \"\"\"\nkeys: str | Sequence[tuple[str, int | str | Mapping[str, Any]]]\nunique: bool = False\nbackground: bool = False\ncollation: Collation | None = None\nsparse: bool = False\nextra: dict[str, Any] = field(default_factory=dict)\n</code></pre>"},{"location":"api-typing/#fastapi_motor_oil.typing.InsertOneOptions","title":"<code>InsertOneOptions</code>","text":"<p>             Bases: <code>TypedDict</code></p> <p>Insert options.</p> Source code in <code>fastapi_motor_oil/typing.py</code> <pre><code>class InsertOneOptions(TypedDict, total=False):\n\"\"\"\n    Insert options.\n    \"\"\"\nbypass_document_validation: bool  # Default is False\nsession: AgnosticCollection | None  # Default is None\ncomment: Any | None  # Default is None\n</code></pre>"},{"location":"api-typing/#fastapi_motor_oil.typing.UpdateManyOptions","title":"<code>UpdateManyOptions</code>","text":"<p>             Bases: <code>TypedDict</code></p> <p>Update-many options.</p> Source code in <code>fastapi_motor_oil/typing.py</code> <pre><code>class UpdateManyOptions(TypedDict, total=False):\n\"\"\"\n    Update-many options.\n    \"\"\"\nupsert: bool  # Default is False\narray_filters: Sequence[Mapping[str, Any]] | None  # Default is None\nbypass_document_validation: bool  # Default is None\ncollation: Mapping[str, Any] | Collation | None  # Default is None\nhint: str | Sequence[tuple[str, int | str | Mapping[str, Any]]] | None  # Default is None\nsession: AgnosticCollection | None  # Default is None\nlet: Mapping[str, Any] | None  # Default is None\ncomment: Any | None  # Default is None\n</code></pre>"},{"location":"api-typing/#fastapi_motor_oil.typing.UpdateOneOptions","title":"<code>UpdateOneOptions</code>","text":"<p>             Bases: <code>TypedDict</code></p> <p>Update-one options.</p> Source code in <code>fastapi_motor_oil/typing.py</code> <pre><code>class UpdateOneOptions(TypedDict, total=False):\n\"\"\"\n    Update-one options.\n    \"\"\"\nupsert: bool  # Default is False\nbypass_document_validation: bool  # Default is False\ncollation: Mapping[str, Any] | Collation | None  # Default is None\narray_filters: Sequence[Mapping[str, Any]]  # Default is None\nhint: str | Sequence[tuple[str, int | str | Mapping[str, Any]]] | None  # Default is None\nsession: AgnosticCollection | None  # Default is None\nlet: Mapping[str, Any] | None  # Default is None\ncomment: Any | None  # Default is None\n</code></pre>"},{"location":"api-validator/","title":"Validators","text":""},{"location":"api-validator/#fastapi_motor_oil.validator.Validator","title":"<code>Validator</code>","text":"<p>             Bases: <code>BoundMethodWrapper[TOwner, [MongoQuery | None, TInsertOrUpdate], InsertUpdateConfig]</code></p> <p>Validator method wrapper.</p> <p>Validator methods receive an insert or update object, and execute some - potentially async - operations to make sure the inserted or updated data is valid.</p> Source code in <code>fastapi_motor_oil/validator.py</code> <pre><code>class Validator(BoundMethodWrapper[TOwner, [MongoQuery | None, TInsertOrUpdate], InsertUpdateConfig]):\n\"\"\"\n    Validator method wrapper.\n    Validator methods receive an insert or update object, and execute some - potentially\n    async - operations to make sure the inserted or updated data is valid.\n    \"\"\"\n__slots__ = ()\nexception = ValidationError\n</code></pre>"},{"location":"api-validator/#fastapi_motor_oil.validator.validator","title":"<code>validator(config='insert-update')</code>","text":"<p>Service method decorator factory that converts the decorated method into a <code>Validator</code> instance.</p> <p>Example:</p> <pre><code>class SVC(MongoService):\n@validator(\"update\")\ndef check_something(self, data: InsertData | CreateData) -&gt; None:\nraise ValueError(\"Always fail.\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>InsertUpdateConfig</code> <p>Validatator config.</p> <code>'insert-update'</code> Source code in <code>fastapi_motor_oil/validator.py</code> <pre><code>def validator(\nconfig: InsertUpdateConfig = \"insert-update\",\n) -&gt; Callable[\n[Callable[[TOwner, MongoQuery | None, TInsertOrUpdate], Coroutine[None, None, None]]],\n\"Validator[TOwner, TInsertOrUpdate]\",\n]:\n\"\"\"\n    Service method decorator factory that converts the decorated method into a `Validator` instance.\n    Example:\n    ```python\n    class SVC(MongoService):\n        @validator(\"update\")\n        def check_something(self, data: InsertData | CreateData) -&gt; None:\n            raise ValueError(\"Always fail.\")\n    ```\n    Arguments:\n        config: Validatator config.\n    \"\"\"\ndef decorator(\nfunc: Callable[[TOwner, MongoQuery | None, TInsertOrUpdate], Coroutine[None, None, None]], /\n) -&gt; \"Validator[TOwner, TInsertOrUpdate]\":\nreturn Validator(func=func, config=config)\nreturn decorator\n</code></pre>"},{"location":"fastapi-example/","title":"FastAPI example","text":"<p>In this is example we will:</p> <ul> <li>create a simple <code>TreeNode</code> document model with a name, a creation date, and an optional reference to a parent node;</li> <li>prepare all the services that are necessary to create, read, update, or delete documents;</li> <li>declare a couple of delete rules and validators that enforce consistency;</li> <li>declare a unique name index for the <code>TreeNode</code> collection;</li> <li>implement a <code>fastapi</code> <code>APIRouter</code> factory that can be included in <code>fastapi</code> applications;</li> <li>set up the <code>fastapi</code> application itself;</li> <li>implement automatic index creation in the application's lifespan method.</li> </ul>"},{"location":"fastapi-example/#prerequisites","title":"Prerequisites","text":"<p>To follow and try this example, you will need:</p> <ul> <li>Python 3.10+;</li> <li>access to a MongoDB database (e.g. a Community Edition running locally);</li> <li><code>fastapi</code> with all its dependencies (<code>pip install fastapi[all]</code>);</li> <li>and of course this library.</li> </ul>"},{"location":"fastapi-example/#project-layout","title":"Project layout","text":"<p>Create the root directory of your project, for example <code>tree-app</code>.</p> <p>Inside the root directory, create the root Python package for the application -- <code>tree_app</code> -- and add the following empty files to:</p> <ul> <li><code>__init__.py</code></li> <li><code>api.py</code></li> <li><code>main.py</code></li> <li><code>model.py</code></li> <li><code>service.py</code></li> </ul> <p>In the end, your directory structure should look like this:</p> <ul> <li><code>tree-app</code> (root directory)</li> <ul> <li><code>tree_app</code> (root package)</li> <ul> <li><code>__init__.py</code></li> <li><code>api.py</code></li> <li><code>main.py</code></li> <li><code>model.py</code></li> <li><code>service.py</code></li> </ul> </ul> </ul>"},{"location":"fastapi-example/#model","title":"Model","text":"<p>First we will implement the data model in <code>model.py</code>. Actually, we will implement three (<code>pydantic</code>) model classes, one for document serialization, one for creation, and one for editing.</p> <pre><code>from fastapi_motor_oil import DocumentModel, StrObjectId, UTCDatetime\nfrom pydantic import BaseModel\nclass TreeNode(DocumentModel):\n\"\"\"\n    Tree node document model.\n    \"\"\"\nname: str\nparent: StrObjectId | None\ncreated_at: UTCDatetime\nclass TreeNodeCreate(BaseModel):\n\"\"\"\n    Tree node creation model.\n    \"\"\"\nname: str\nparent: StrObjectId | None\nclass TreeNodeUpdate(BaseModel):\n\"\"\"\n    Tree node update model.\n    \"\"\"\nname: str | None\nparent: StrObjectId | None\n</code></pre>"},{"location":"fastapi-example/#services","title":"Services","text":"<p>With the model in place, we can start working on the services (<code>service.py</code>) that we will use from the REST routes. This step is as simple as subclassing <code>MongoService</code> and specifying the collection name:</p> <pre><code>from typing import Any\nfrom datetime import datetime, timezone\nfrom fastapi_motor_oil import CollectionOptions, MongoService\nfrom .model import TreeNodeCreate, TreeNodeUpdate\nclass TreeNodeService(MongoService[TreeNodeCreate, TreeNodeUpdate]):\n\"\"\"\n    Tree node database services.\n    \"\"\"\n__slots__ = ()\ncollection_name: str = \"tree_nodes\"\ncollection_options: CollectionOptions | None = None\nasync def _convert_for_insert(self, data: TreeNodeCreate) -&gt; dict[str, Any]:\nreturn {\n**(await super()._convert_for_insert(data)),\n\"created_at\": datetime.now(timezone.utc),\n}\n</code></pre> <p>Noticate that <code>TreeNodeCreate</code> does not have a <code>created_at</code> attribute. Instead we inject this attribute during creation by overriding the <code>_convert_for_insert()</code> method of the service.</p> <p>That could be it, but we want to enforce a level of consistency in the database. To do that, we will add a couple of delete rules and validators to the service.</p> <p>Note that the rules below do not fully enforce a tree structure, but they are good enough for demonstration purposes.</p> <pre><code>from typing import Any\nfrom collections.abc import Sequence\nfrom datetime import datetime, timezone\nfrom bson import ObjectId\nfrom fastapi_motor_oil import CollectionOptions, MongoQuery, MongoService, delete_rule, validator\nfrom motor.core import AgnosticClientSession\nfrom .model import TreeNodeCreate, TreeNodeUpdate\nclass TreeNodeService(MongoService[TreeNodeCreate, TreeNodeUpdate]):\n\"\"\"\n    Tree node database services.\n    \"\"\"\n__slots__ = ()\ncollection_name: str = \"tree_nodes\"\ncollection_options: CollectionOptions | None = None\n@delete_rule(\"pre\")  # Delete rule that remove the subtrees of deleted nodes.\nasync def dr_delete_subtree(self, session: AgnosticClientSession, ids: Sequence[ObjectId]) -&gt; None:\nchild_ids = await self.find_ids({\"parent\": {\"$in\": ids}}, session=session)\nif len(child_ids) &gt; 0:\n# Recursion\nawait self.delete_many({\"_id\": {\"$in\": child_ids}}, options={\"session\": session})\n@delete_rule(\"deny\")  # Delete rule that prevents the removal of root nodes.\nasync def dr_deny_if_root(self, session: AgnosticClientSession, ids: Sequence[ObjectId]) -&gt; None:\nroot_cnt = await self.count_documents(\n{\"$and\": [{\"_id\": {\"$in\": ids}}, {\"parent\": None}]},\noptions={\"session\": session},\n)\nif root_cnt &gt; 0:\nraise ValueError(\"Can not delete root nodes.\")\n@validator(\"insert-update\")\nasync def v_parent_valid(self, query: MongoQuery | None, data: TreeNodeCreate | TreeNodeUpdate) -&gt; None:\nif data.parent is None:  # No parent node is always fine\nreturn\nif not await self.exists(data.parent):  # Parent must exist.\nraise ValueError(\"Parent does not exist.\")\nif isinstance(data, TreeNodeCreate):  # No more checks during creation.\nreturn\nmatched_ids = (await self.find_ids(query)) if isinstance(data, TreeNodeUpdate) else []\nif data.parent in matched_ids:  # Self reference is forbidden.\nraise ValueError(\"Self-reference.\")\nasync def _convert_for_insert(self, data: TreeNodeCreate) -&gt; dict[str, Any]:\nreturn {\n**(await super()._convert_for_insert(data)),\n\"created_at\": datetime.now(timezone.utc),\n}\n</code></pre> <p>Finally, we will declare the indexes of the collection by setting <code>TreeNodeService.indexes</code>, which must be an index name - <code>IndexData</code> dictionary. A unique, ascending, case-insensitive index on the <code>name</code> attribute can be declared like this:</p> <pre><code>...\nfrom fastapi_motor_oil import IndexData, MongoService\n...\nfrom .model import TreeNodeCreate, TreeNodeUpdate\n...\nclass TreeNodeService(MongoService[TreeNodeCreate, TreeNodeUpdate]):\n...\nindexes = {\n\"unique-name\": IndexData(\nkeys=\"name\",\nunique=True,\ncollation={\"locale\": \"en\", \"strength\": 1},\n),\n}\n...\n</code></pre> <p>For all indexing options, please see the PyMongo documentation.</p> <p>Combining everything together, the final service implementation looks like this:</p> <pre><code>from typing import Any\nfrom collections.abc import Sequence\nfrom datetime import datetime, timezone\nfrom bson import ObjectId\nfrom fastapi_motor_oil import CollectionOptions, IndexData, MongoQuery, MongoService, delete_rule, validator\nfrom motor.core import AgnosticClientSession\nfrom .model import TreeNodeCreate, TreeNodeUpdate\nclass TreeNodeService(MongoService[TreeNodeCreate, TreeNodeUpdate]):\n\"\"\"\n    Tree node database services.\n    \"\"\"\n__slots__ = ()\ncollection_name: str = \"tree_nodes\"\ncollection_options: CollectionOptions | None = None\nindexes = {\n\"unique-name\": IndexData(\nkeys=\"name\",\nunique=True,\ncollation={\"locale\": \"en\", \"strength\": 1},\n),\n}\n@delete_rule(\"pre\")  # Delete rule that remove the subtrees of deleted nodes.\nasync def dr_delete_subtree(self, session: AgnosticClientSession, ids: Sequence[ObjectId]) -&gt; None:\nchild_ids = await self.find_ids({\"parent\": {\"$in\": ids}}, session=session)\nif len(child_ids) &gt; 0:\n# Recursion\nawait self.delete_many({\"_id\": {\"$in\": child_ids}}, options={\"session\": session})\n@delete_rule(\"deny\")  # Delete rule that prevents the removal of root nodes.\nasync def dr_deny_if_root(self, session: AgnosticClientSession, ids: Sequence[ObjectId]) -&gt; None:\nroot_cnt = await self.count_documents(\n{\"$and\": [{\"_id\": {\"$in\": ids}}, {\"parent\": None}]},\noptions={\"session\": session},\n)\nif root_cnt &gt; 0:\nraise ValueError(\"Can not delete root nodes.\")\n@validator(\"insert-update\")\nasync def v_parent_valid(self, query: MongoQuery | None, data: TreeNodeCreate | TreeNodeUpdate) -&gt; None:\nif data.parent is None:  # No parent node is always fine\nreturn\nif not await self.exists(data.parent):  # Parent must exist.\nraise ValueError(\"Parent does not exist.\")\nif isinstance(data, TreeNodeCreate):  # No more checks during creation.\nreturn\nmatched_ids = (await self.find_ids(query)) if isinstance(data, TreeNodeUpdate) else []\nif data.parent in matched_ids:  # Self reference is forbidden.\nraise ValueError(\"Self-reference.\")\nasync def _convert_for_insert(self, data: TreeNodeCreate) -&gt; dict[str, Any]:\nreturn {\n**(await super()._convert_for_insert(data)),\n\"created_at\": datetime.now(timezone.utc),\n}\n</code></pre> <p>With the service implementation ready, we can move on to creating the REST API.</p>"},{"location":"fastapi-example/#routing","title":"Routing","text":"<p>In <code>api.py</code>, we will use the factory pattern to create an <code>APIRouter</code> instance for the <code>fastapi</code> application:</p> <pre><code>from typing import Any\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom fastapi_motor_oil import AgnosticDatabase, DatabaseProvider, DeleteError, DeleteResultModel, StrObjectId\nfrom .model import TreeNode, TreeNodeCreate, TreeNodeUpdate\nfrom .service import TreeNodeService\ndef make_api(\n*,\nget_database: DatabaseProvider,\nprefix: str = \"/tree-node\",\n) -&gt; APIRouter:\n\"\"\"\n    Tree node `APIRouter` factory.\n    Arguments:\n        get_database: FastAPI dependency that returns the `AgnosticDatabase`\n                      database instance for the API.\n        prefix: The prefix for the created `APIRouter`.\n    Returns:\n        The created `APIRouter` instance.\n    \"\"\"\napi = APIRouter(prefix=prefix)\n@api.get(\"/\", response_model=list[TreeNode])\nasync def get_all(\ndatabase: AgnosticDatabase = Depends(get_database),\n) -&gt; list[dict[str, Any]]:\nsvc = TreeNodeService(database)\nreturn [d async for d in svc.find()]\n@api.post(\"/\", response_model=TreeNode)\nasync def create(\ndata: TreeNodeCreate,\ndatabase: AgnosticDatabase = Depends(get_database),\n) -&gt; dict[str, Any]:\nsvc = TreeNodeService(database)\ntry:\nresult = await svc.insert_one(data)\nexcept Exception:\nraise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=\"Creation failed.\")\nif (created := await svc.get_by_id(result.inserted_id)) is not None:\nreturn created\nraise HTTPException(status.HTTP_409_CONFLICT)\n@api.get(\"/{id}\", response_model=TreeNode)\nasync def get_by_id(\nid: StrObjectId,\ndatabase: AgnosticDatabase = Depends(get_database),\n) -&gt; dict[str, Any]:\nsvc = TreeNodeService(database)\nif (result := await svc.get_by_id(id)) is not None:\nreturn result\nraise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(id))\n@api.put(\"/{id}\", response_model=TreeNode)\nasync def update_by_id(\nid: StrObjectId,\ndata: TreeNodeUpdate,\ndatabase: AgnosticDatabase = Depends(get_database),\n) -&gt; dict[str, Any]:\nsvc = TreeNodeService(database)\ntry:\nresult = await svc.update_by_id(id, data)\nexcept Exception:\nraise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(id))\nif result.matched_count == 0:\nraise HTTPException(status.HTTP_404_NOT_FOUND, detail=str(id))\nif (updated := await svc.get_by_id(id)) is not None:\nreturn updated\nraise HTTPException(status.HTTP_404_NOT_FOUND, detail=str(id))\n@api.delete(\"/{id}\", response_model=DeleteResultModel)\nasync def delete_by_id(\nid: StrObjectId,\ndatabase: AgnosticDatabase = Depends(get_database),\n) -&gt; DeleteResultModel:\nsvc = TreeNodeService(database)\ntry:\nresult = await svc.delete_by_id(id)\nexcept DeleteError:\nraise HTTPException(status.HTTP_400_BAD_REQUEST, detail=str(id))\nif result.deleted_count == 0:\nraise HTTPException(status.HTTP_404_NOT_FOUND, detail=str(id))\nreturn DeleteResultModel(delete_count=result.deleted_count)\nreturn api\n</code></pre>"},{"location":"fastapi-example/#the-application","title":"The application","text":"<p>Finally, we can create the application itself and include our routes in it:</p> <pre><code>from contextlib import asynccontextmanager\nfrom functools import lru_cache\nfrom fastapi import FastAPI\nfrom motor.motor_asyncio import AsyncIOMotorClient, AsyncIOMotorDatabase\n@lru_cache(maxsize=1)\ndef get_database() -&gt; AsyncIOMotorDatabase:\n\"\"\"Database provider dependency for the created API.\"\"\"\nmongo_connection_string = \"mongodb://127.0.0.1:27017\"\ndatabase_name = \"tree-db\"\nclient = AsyncIOMotorClient(mongo_connection_string)\nreturn client[database_name]\n@asynccontextmanager\nasync def lifespan(app: FastAPI) -&gt; AsyncGenerator[None, None]:\n# Create all indexes on startup if they don't exist already.\nfrom .service import TreeNodeService\ndb = get_database(get_client())\nawait TreeNodeService(db).create_indexes()\nyield  # Application starts\ndef register_routes(app: FastAPI) -&gt; None:\n\"\"\"Registers all routes of the application.\"\"\"\nfrom .api import make_api as make_tree_node_api\napi_prefix = \"/api/v1\"\napp.include_router(\nmake_tree_node_api(get_database=get_database),\nprefix=api_prefix,\n)\ndef create_app() -&gt; FastAPI:\napp = FastAPI(lifespan=lifespan)  # Set lifespan method.\nregister_routes(app)\nreturn app\n</code></pre> <p>Notice the async <code>lifespan()</code> method (context manager) that creates the declared indexes before the application starts serving requests by calling the <code>create_indexes()</code> method of each service. There are of course many other ways for adding index creation (or recreation) to an application, like database migration or command line tools. Doing it in the <code>lifespan</code> method of the application is just one, easy to implement solution that works well for relatively small databases.</p>"},{"location":"fastapi-example/#run","title":"Run","text":"<p>With everything ready, we can start the application by executing <code>uvicorn tree_app.main:create_app --reload --factory</code> in the root directory and go to http://127.0.0.1:8000/docs to try the created REST API.</p>"}]}